<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apache SkyWalking – Apache SkyWalking</title>
    <link>https://skywalking.apache.org/</link>
    <description>Recent content on Apache SkyWalking</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://skywalking.apache.org/index.xml" rel="self" type="application/rss+xml" />
    
    
      
      
    
    
    <item>
      <title>Blog: Observe Service Mesh with SkyWalking and Envoy Access Log Service</title>
      <link>https://skywalking.apache.org/blog/2020-12-03-obs-service-mesh-with-sw-and-als/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-12-03-obs-service-mesh-with-sw-and-als/</guid>
      <description>
        
        
        &lt;p&gt;&lt;img src=&#34;canyonhorseshoe.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Author: Zhenxu Ke, Sheng Wu, and Tevah Platt. tetrate.io&lt;/li&gt;
&lt;li&gt;Original link, &lt;a href=&#34;https://www.tetrate.io/blog/observe-service-mesh-with-skywalking-and-envoy-access-log-service/&#34;&gt;Tetrate.io blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dec. 03th, 2020&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apache/skywalking&#34;&gt;Apache SkyWalking&lt;/a&gt;: an APM (application performance monitor) system, especially designed for microservices, cloud native, and container-based (Docker, Kubernetes, Mesos) architectures.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/service/accesslog/v2/als.proto&#34;&gt;Envoy Access Log Service&lt;/a&gt;: Access Log Service (ALS) is an Envoy extension that emits detailed access logs of all requests going through Envoy.&lt;/p&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;Apache SkyWalking has long supported observability in service mesh with Istio Mixer adapter. But since v1.5, Istio began to deprecate Mixer due to its poor performance in large scale clusters. Mixer’s functionalities have been moved into the Envoy proxies, and is supported only through the 1.7 Istio release.
On the other hand, &lt;a href=&#34;https://github.com/wu-sheng&#34;&gt;Sheng Wu&lt;/a&gt; and &lt;a href=&#34;https://github.com/lizan&#34;&gt;Lizan Zhou&lt;/a&gt; presented a better solution based on the Apache SkyWalking and Envoy ALS on &lt;a href=&#34;https://kccncosschn19eng.sched.com/event/NroB/observability-in-service-mesh-powered-by-envoy-and-apache-skywalking-sheng-wu-lizan-zhou-tetrate&#34;&gt;KubeCon China 2019&lt;/a&gt;,  to reduce the performance impact brought by Mixer, while retaining the same observability in service mesh. This solution was initially implemented by Sheng Wu, &lt;a href=&#34;https://github.com/hanahmily&#34;&gt;Hongtao Gao&lt;/a&gt;, Lizan Zhou, and &lt;a href=&#34;https://github.com/dio&#34;&gt;Dhi Aurrahman&lt;/a&gt; at Tetrate.io.
If you are looking for a more efficient solution to observe your service mesh instead of using a Mixer-based solution, this is exactly what you need. In this tutorial, we will explain a little bit how the new solution works, and apply it to the bookinfo application in practice.&lt;/p&gt;
&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;
&lt;p&gt;From a perspective of observability, Envoy can be typically deployed in 2 modes, sidecar, and router. As a sidecar, Envoy mostly represents a single service to receive and send requests (2 and 3 in the picture below). While as a proxy, Envoy may represent many services (1 in the picture below).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Screen-Shot-2020-12-02-at-2.25.17-PM.png&#34; alt=&#34;Example of Envoy deployment, as front proxy and sidecar&#34;&gt;&lt;/p&gt;
&lt;p&gt;In both modes, the logs emitted by ALS include a node identifier. The identifier starts with &lt;code&gt;router~&lt;/code&gt; (or &lt;code&gt;ingress~&lt;/code&gt;) in router mode and &lt;code&gt;sidecar~&lt;/code&gt; in sidecar proxy mode.&lt;/p&gt;
&lt;p&gt;Apart from the node identifier, there are &lt;a href=&#34;https://github.com/envoyproxy/envoy/blob/549164c42cae84b59154ca4c36009e408aa10b52/generated_api_shadow/envoy/data/accesslog/v2/accesslog.proto&#34;&gt;several noteworthy properties in the access logs&lt;/a&gt; that will be used in this solution:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;downstream_direct_remote_address&lt;/code&gt;: This field is the downstream direct remote address on which the request from the user was received. Note: This is always the physical peer, even if the remote address is inferred from for example the &lt;code&gt;x-forwarded-for&lt;/code&gt; header, proxy protocol, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;downstream_remote_address&lt;/code&gt;: The remote/origin address on which the request from the user was received.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;downstream_local_address&lt;/code&gt;: The local/destination address on which the request from the user was received.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;upstream_remote_address&lt;/code&gt;: The upstream remote/destination address that handles this exchange.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;upstream_local_address&lt;/code&gt;: The upstream local/origin address that handles this exchange.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;upstream_cluster&lt;/code&gt;: The upstream cluster that &lt;em&gt;upstream_remote_address&lt;/em&gt; belongs to.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will discuss more about the properties in the following sections.&lt;/p&gt;
&lt;h3 id=&#34;sidecar&#34;&gt;Sidecar&lt;/h3&gt;
&lt;p&gt;When serving as a sidecar, Envoy is deployed alongside a service, and delegates all the incoming/outgoing requests to/from the service.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Delegating incoming requests:&lt;/strong&gt; in this case, Envoy acts as a server side sidecar, and sets the &lt;code&gt;upstream_cluster&lt;/code&gt; in form of &lt;code&gt;inbound|portNumber|portName|Hostname[or]SidecarScopeID&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Screen-Shot-2020-12-02-at-2.37.49-PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The SkyWalking analyzer checks whether either &lt;code&gt;downstream_remote_address&lt;/code&gt; can be mapped to a Kubernetes service:&lt;/p&gt;
&lt;p&gt;a. If there is a service (say &lt;code&gt;Service B&lt;/code&gt;) whose implementation is running in this IP(and port), then we have a service-to-service relation, &lt;code&gt;Service B -&amp;gt; Service A&lt;/code&gt;, which can be used to build the topology. Together with the &lt;code&gt;start_time&lt;/code&gt; and &lt;code&gt;duration&lt;/code&gt; fields in the access log, we have the latency metrics now.&lt;/p&gt;
&lt;p&gt;b. If there is no service that can be mapped to &lt;code&gt;downstream_remote_address&lt;/code&gt;, then the request may come from a service out of the mesh. Since SkyWalking cannot identify the source service where the requests come from, it simply generates the metrics without source service, according to the &lt;a href=&#34;https://wu-sheng.github.io/STAM/&#34;&gt;topology analysis method&lt;/a&gt;. The topology can be built as accurately as possible, and the metrics detected from server side are still correct.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Delegating outgoing requests:&lt;/strong&gt; in this case, Envoy acts as a client-side sidecar, and sets the &lt;code&gt;upstream_cluster&lt;/code&gt; in form of &lt;code&gt;outbound|&amp;lt;port&amp;gt;|&amp;lt;subset&amp;gt;|&amp;lt;serviceFQDN&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Screen-Shot-2020-12-02-at-2.43.16-PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Client side detection is relatively simpler than (1. Delegating incoming requests). If &lt;code&gt;upstream_remote_address&lt;/code&gt; is another sidecar or proxy, we simply get the mapped service name and generate the topology and metrics. Otherwise, we have no idea what it is and consider it an &lt;code&gt;UNKNOWN&lt;/code&gt; service.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;proxy-role&#34;&gt;Proxy role&lt;/h3&gt;
&lt;p&gt;When Envoy is deployed as a proxy, it is an independent service itself and doesn&amp;rsquo;t represent any other service like a sidecar does. Therefore, we can build client-side metrics as well as server-side metrics.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Screen-Shot-2020-12-02-at-2.46.56-PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;p&gt;In this section, we will use the typical &lt;a href=&#34;https://istio.io/latest/docs/examples/bookinfo/&#34;&gt;bookinfo application&lt;/a&gt; to demonstrate how  Apache SkyWalking 8.3.0+ (the latest version up to Nov. 30th, 2020) works together with Envoy ALS to observe a service mesh.&lt;/p&gt;
&lt;h3 id=&#34;installing-kubernetes&#34;&gt;Installing Kubernetes&lt;/h3&gt;
&lt;p&gt;SkyWalking 8.3.0 supports the Envoy ALS solution under both Kubernetes environment and virtual machines (VM) environment, in this tutorial, we’ll only focus on the Kubernetes scenario, for VM solution, please stay tuned for our next blog, so we need to install Kubernetes before taking further steps.&lt;/p&gt;
&lt;p&gt;In this tutorial, we will use the &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/&#34;&gt;Minikube&lt;/a&gt; tool to quickly set up a local Kubernetes(v1.17) cluster for testing. In order to run all the needed components, including the bookinfo application, the SkyWalking OAP and WebUI, the cluster may need up to 4GB RAM and 2 CPU cores.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;minikube start --memory&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4096&lt;/span&gt; --cpus&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Next, run &lt;code&gt;kubectl get pods --namespace=kube-system --watch&lt;/code&gt; to check whether all the Kubernetes components are ready. If not, wait for the readiness before going on.&lt;/p&gt;
&lt;h3 id=&#34;installing-istio&#34;&gt;Installing Istio&lt;/h3&gt;
&lt;p&gt;Istio provides a very convenient way to configure the Envoy proxy and enable the access log service. The built-in configuration profiles free us from lots of manual operations. So, for demonstration purposes, we will use Istio through this tutorial.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ISTIO_VERSION&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1.7.1
curl -L https://istio.io/downloadIstio &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt; sh - 
sudo mv &lt;span style=&#34;color:#000&#34;&gt;$PWD&lt;/span&gt;/istio-&lt;span style=&#34;color:#000&#34;&gt;$ISTIO_VERSION&lt;/span&gt;/bin/istioctl /usr/local/bin/
istioctl  install --set &lt;span style=&#34;color:#000&#34;&gt;profile&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;demo
kubectl label namespace default istio-injection&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Run &lt;code&gt;kubectl get pods --namespace=istio-system --watch&lt;/code&gt; to check whether all the Istio components are ready. If not, wait for the readiness before going on.&lt;/p&gt;
&lt;h3 id=&#34;enabling-als&#34;&gt;Enabling ALS&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;demo&lt;/code&gt; profile doesn’t enable ALS by default. We need to reconfigure it to enable ALS via some configuration.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;istioctl  manifest install &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set meshConfig.enableEnvoyAccessLogService&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set meshConfig.defaultConfig.envoyAccessLogService.address&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;skywalking-oap.istio-system:11800
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The example command &lt;code&gt;--set meshConfig.enableEnvoyAccessLogService=true&lt;/code&gt; enables the Envoy access log service in the mesh. And as we said earlier, ALS is essentially a gRPC service that emits requests logs. The config &lt;code&gt;meshConfig.defaultConfig.envoyAccessLogService.address=skywalking-oap.istio-system:11800&lt;/code&gt; tells this gRPC service  where to emit the logs, say &lt;code&gt;skywalking-oap.istio-system:11800&lt;/code&gt;, where we will deploy the SkyWalking ALS receiver later.&lt;/p&gt;
&lt;p&gt;NOTE:
You can also enable the ALS when installing Istio so that you don’t need to restart Istio after installation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;istioctl install --set &lt;span style=&#34;color:#000&#34;&gt;profile&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;demo &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set meshConfig.enableEnvoyAccessLogService&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set meshConfig.defaultConfig.envoyAccessLogService.address&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;skywalking-oap.istio-system:11800
kubectl label namespace default istio-injection&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;deploying-apache-skywalking&#34;&gt;Deploying Apache SkyWalking&lt;/h3&gt;
&lt;p&gt;The SkyWalking community provides a &lt;a href=&#34;https://helm.sh&#34;&gt;Helm&lt;/a&gt; Chart to make it easier to deploy SkyWalking and its dependent services in Kubernetes. The Helm Chart can be found at the &lt;a href=&#34;https://github.com/apache/skywalking-kubernetes&#34;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Install Helm&lt;/span&gt;
curl -sSLO https://get.helm.sh/helm-v3.0.0-linux-amd64.tar.gz
sudo tar xz -C /usr/local/bin --strip-components&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt; linux-amd64/helm -f helm-v3.0.0-linux-amd64.tar.gz
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Clone SkyWalking Helm Chart&lt;/span&gt;
git clone https://github.com/apache/skywalking-kubernetes
&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; skywalking-kubernetes/chart
git reset --hard dd749f25913830c47a97430618cefc4167612e75
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Update dependencies&lt;/span&gt;
helm dep up skywalking
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Deploy SkyWalking&lt;/span&gt;
helm -n istio-system install skywalking skywalking &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set oap.storageType&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;h2&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set ui.image.tag&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;8.3.0 &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set oap.image.tag&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;8.3.0-es7 &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set oap.replicas&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set oap.env.SW_ENVOY_METRIC_ALS_HTTP_ANALYSIS&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;k8s-mesh &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set oap.env.JAVA_OPTS&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;-Dmode=&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set oap.envoy.als.enabled&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;true&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;               --set elasticsearch.enabled&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We deploy SkyWalking to the namespace &lt;code&gt;istio-system&lt;/code&gt;, so that SkyWalking OAP service can be accessed by &lt;code&gt;skywalking-oap.istio-system:11800&lt;/code&gt;, to which we told ALS to emit their logs, in the previous step.&lt;/p&gt;
&lt;p&gt;We also enable the ALS analyzer in the SkyWalking OAP: &lt;code&gt;oap.env.SW_ENVOY_METRIC_ALS_HTTP_ANALYSIS=k8s-mesh&lt;/code&gt;. The analyzer parses the access logs and maps the IP addresses in the logs to the real service names in the Kubernetes, to build a topology.&lt;/p&gt;
&lt;p&gt;In order to retrieve the metadata (such as Pod IP and service names) from a Kubernetes cluster for IP mappings, we also set &lt;code&gt;oap.envoy.als.enabled=true&lt;/code&gt;, to apply for a &lt;code&gt;ClusterRole&lt;/code&gt; that has access to the metadata.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;POD_NAME&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;$(&lt;/span&gt;kubectl get pods -A -l &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;app=skywalking,release=skywalking,component=ui&amp;#34;&lt;/span&gt; -o name&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#204a87&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;$POD_NAME&lt;/span&gt;
kubectl -n istio-system port-forward &lt;span style=&#34;color:#000&#34;&gt;$POD_NAME&lt;/span&gt; 8080:8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now navigate your browser to http://localhost:8080 . You should be able to see the SkyWalking dashboard. The dashboard is empty for now, but after we deploy the demo application and generate traffic, it should be filled up later.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Screen-Shot-2020-12-02-at-3.01.03-PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;deploying-bookinfo-application&#34;&gt;Deploying Bookinfo application&lt;/h3&gt;
&lt;p&gt;Run:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ISTIO_VERSION&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1.7.1
kubectl apply -f https://raw.githubusercontent.com/istio/istio/&lt;span style=&#34;color:#000&#34;&gt;$ISTIO_VERSION&lt;/span&gt;/samples/bookinfo/platform/kube/bookinfo.yaml
kubectl apply -f https://raw.githubusercontent.com/istio/istio/&lt;span style=&#34;color:#000&#34;&gt;$ISTIO_VERSION&lt;/span&gt;/samples/bookinfo/networking/bookinfo-gateway.yaml
kubectl &lt;span style=&#34;color:#204a87&#34;&gt;wait&lt;/span&gt; --for&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;condition&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;Ready pods --all --timeout&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1200s
minikube tunnel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then navigate your browser to http://localhost/productpage. You should be able to see the typical bookinfo application. Refresh the webpage several times to generate enough access logs.&lt;/p&gt;
&lt;h3 id=&#34;done&#34;&gt;Done!&lt;/h3&gt;
&lt;p&gt;And you’re all done! Check out the SkyWalking WebUI again. You should see the topology of the bookinfo application, as well the metrics of each individual service of the bookinfo application.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Screen-Shot-2020-12-02-at-3.05.24-PM.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;Screen-Shot-2020-12-02-at-3.11.55-PM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;troubleshooting&#34;&gt;Troubleshooting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Check all pods status: &lt;code&gt;kubectl get pods -A&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;SkyWalking OAP logs: &lt;code&gt;kubectl -n istio-system logs -f $(kubectl get pod -A -l &amp;quot;app=skywalking,release=skywalking,component=oap&amp;quot; -o name)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;SkyWalking WebUI logs: &lt;code&gt;kubectl -n istio-system logs -f $(kubectl get pod -A -l &amp;quot;app=skywalking,release=skywalking,component=ui&amp;quot; -o name)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Make sure the time zone at the bottom-right of the WebUI is set to &lt;code&gt;UTC +0&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;customizing-service-names&#34;&gt;Customizing Service Names&lt;/h2&gt;
&lt;p&gt;The SkyWalking community brought more improvements to the ALS solution in the 8.3.0 version. You can decide how to compose the service names when mapping from the IP addresses, with variables &lt;code&gt;service&lt;/code&gt; and &lt;code&gt;pod&lt;/code&gt;. For instance, configuring &lt;code&gt;K8S_SERVICE_NAME_RULE&lt;/code&gt; to the expression &lt;code&gt;${service.metadata.name}-${pod.metadata.labels.version}&lt;/code&gt; gets service names with version label such as &lt;code&gt;reviews-v1&lt;/code&gt;, &lt;code&gt;reviews-v2&lt;/code&gt;, and &lt;code&gt;reviews-v3&lt;/code&gt;, instead of a single service &lt;code&gt;reviews&lt;/code&gt;, see &lt;a href=&#34;https://github.com/apache/skywalking/pull/5722&#34;&gt;the PR&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;working-als-with-vm&#34;&gt;Working ALS with VM&lt;/h2&gt;
&lt;p&gt;Kubernetes is popular, but what about VMs? From what we discussed above, in order to map the IPs to services, SkyWalking needs access to the Kubernetes cluster, fetching service metadata and Pod IPs. But in a VM environment, there is no source from which we can fetch those metadata.
In the next post, we will introduce another ALS analyzer based on the Envoy metadata exchange mechanism. With this analyzer, you are able to observe a service mesh in the VM environment. Stay tuned!
If you want to  have commercial support for the ALS solution or hybrid mesh observability, &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34;&gt;Tetrate Service Bridge, TSB&lt;/a&gt; is another good option out there.&lt;/p&gt;
&lt;h2 id=&#34;additional-resources&#34;&gt;Additional Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;KubeCon 2019 Recorded &lt;a href=&#34;https://www.youtube.com/watch?v=tERm39ju9ew&#34;&gt;Video&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Get more SkyWalking updates on &lt;a href=&#34;https://skywalking.apache.org&#34;&gt;the official website&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Apache SkyWalking founder Sheng Wu, SkyWalking core maintainer Zhenxu Ke are Tetrate engineers, and Tevah Platt is a content writer for Tetrate. Tetrate helps organizations adopt open source service mesh tools, including Istio, Envoy, and Apache SkyWalking, so they can manage microservices, run service mesh on any infrastructure, and modernize their applications.&lt;/em&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: The first design of Satellite 0.1.0</title>
      <link>https://skywalking.apache.org/blog/2020-11-25-skywalking-satellite-0.1.0-design/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-11-25-skywalking-satellite-0.1.0-design/</guid>
      <description>
        
        
        &lt;p&gt;&lt;img src=&#34;Satellite.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Author: &lt;a href=&#34;https://github.com/evanljp&#34;&gt;Jiapeng Liu&lt;/a&gt;. Baidu.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/skywalking-satellite&#34;&gt;skywalking-satellite&lt;/a&gt;: The Sidecar Project of Apache SkyWalking&lt;/li&gt;
&lt;li&gt;Nov. 25th, 2020&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A lightweight collector/sidecar which can be deployed close to the target monitored system, to collect metrics, traces, and logs. It also provides advanced features, such as local cache, format transformation, and sampling.&lt;/p&gt;
&lt;h2 id=&#34;design-thinking&#34;&gt;Design Thinking&lt;/h2&gt;
&lt;p&gt;Satellite is a 2 level system to collect observability data from other core systems. So, the core element of the design is to guarantee data stability during Pod startup all the way to Pod shutdown avoiding alarm loss. All modules are designed as plugins, and if you have other ideas, you can add them yourself.&lt;/p&gt;
&lt;h2 id=&#34;slo&#34;&gt;SLO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Single gatherer supports &amp;gt; 1000 ops (Based 0.5 Core,50M)&lt;/li&gt;
&lt;li&gt;At least once delivery.(Optional)&lt;/li&gt;
&lt;li&gt;Data stability: 99.999%.(Optional)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Because they are influenced by the choice of plugins, some items in SLO are optional.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;role&#34;&gt;Role&lt;/h2&gt;
&lt;p&gt;Satellite would be running as a &lt;strong&gt;Sidecar&lt;/strong&gt;. Although Daemonset mode would take up fewer resources, it will cause more troubles to the forwarding of agents. So we also want to use Sidecar mode by reducing the costs. But Daemonset mode would be also supported in the future plan.&lt;/p&gt;
&lt;h2 id=&#34;core-modules&#34;&gt;Core Modules&lt;/h2&gt;
&lt;p&gt;The Satellite has 3 core modules which are Gatherer, Processor, and Sender.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Gatherer module is responsible for fetching or receiving data and pushing the data to Queue.&lt;/li&gt;
&lt;li&gt;The Processor module is responsible for reading data from the queue and processing data by a series of filter chains.&lt;/li&gt;
&lt;li&gt;The Sender module is responsible for async processing and forwarding the data to the external services in the batch mode. After sending success, Sender would also acknowledge the offset of Queue in Gatherer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;core-modules.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;detailed-structure&#34;&gt;Detailed Structure&lt;/h2&gt;
&lt;p&gt;The overall design is shown in detail in the figure below. We will explain the specific components one by one.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;detail-modules.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;gatherer&#34;&gt;Gatherer&lt;/h3&gt;
&lt;h4 id=&#34;concepts&#34;&gt;Concepts&lt;/h4&gt;
&lt;p&gt;The Gatherer has 4 components to support the data collection, which are Input, Collector, Worker, and Queue. There are 2 roles in the Worker, which are Fetcher and Receiver.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Input is an abstraction of the input source, which is usually mapped to a configuration file.&lt;/li&gt;
&lt;li&gt;The Collector is created by the Source, but many collectors could be created by the same Source. For example, when a log path has been configured as the /var/*.log in an Input, the number of collectors is the same as the file number in this path.&lt;/li&gt;
&lt;li&gt;The Fetcher and Receiver is the real worker to collect data. The receiver interface is an abstraction, which has multiple implementations, such as gRPC receiver  and HTTP receiver.Here are some specific use cases:
&lt;ul&gt;
&lt;li&gt;Trace Receiver is a gRPC server for receiving trace data created by Skywalking agents.&lt;/li&gt;
&lt;li&gt;Log Receiver is also a gRPC server for receiving log data which is collected by Skywalking agents. (In the future we want Skywalking Agent to support log sending, and RPC-based log sending is more efficient and needs fewer resources than file reading. For example, the way of file reading will bring IO pressure and performance cost under multi-line splicing.)&lt;/li&gt;
&lt;li&gt;Log Fetcher is like Filebeat, which fits the common log collection scenario. This fetcher will have more responsibility than any other workers because it needs to record the offset and process the multi-line splicing. This feature will be implemented in the future.&lt;/li&gt;
&lt;li&gt;Prometheus Fetcher supports a new way to fetch Prometheus data and push the data to the upstream.&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The Queue is a buffer module to decouple collection and transmission. In the 1st release version, we will use persistent storage to ensure data stability. But the implementation is a plug-in design that can support pure memory queues later.
&lt;img src=&#34;gatherer.jpg&#34; alt=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;the-data-flow&#34;&gt;The data flow&lt;/h4&gt;
&lt;p&gt;We use the Trace Receiver as an example to introduce the data flow.
&lt;img src=&#34;DataFlow.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;queue&#34;&gt;Queue&lt;/h4&gt;
&lt;h5 id=&#34;mmapqueue&#34;&gt;MmapQueue&lt;/h5&gt;
&lt;p&gt;We have simplified the design of MmapQueue to reduce the resources cost on the memory and disk.&lt;/p&gt;
&lt;h6 id=&#34;concepts-1&#34;&gt;Concepts&lt;/h6&gt;
&lt;p&gt;There are 2 core concepts in MmapQueue.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Segment: Segment is the real data store center, that provides large-space storage and does not reduce read and write performance as much as possible by using mmap. And we will avoid deleting files by reusing them.&lt;/li&gt;
&lt;li&gt;Meta: The purpose of meta is to find the data that the consumer needs.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;segment&#34;&gt;Segment&lt;/h6&gt;
&lt;p&gt;One MmapQueue has a directory to store the whole data. The Queue directory is made up with many segments and 1 meta file. The number of the segments would be computed by 2 params, which are the max cost of the Queue and the cost of each segment. For example, If the max cost is 512M and each segment cost is 256K, the directory can hold up to 2000 files. Once capacity is exceeded, an coverage policy is adopted that means the 2000th would override the first file.&lt;/p&gt;
&lt;p&gt;Each segment in Queue will be N times the size of the page cache and will be read and written in an appended sequence rather than randomly. These would improve the performance of Queue. For example, each Segment is a 128k file, as shown in the figure below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;segments.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;meta&#34;&gt;Meta&lt;/h6&gt;
&lt;p&gt;The Meta is a mmap file that only contains 56Bit. There are 5 concepts in the Meta.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version: A version flag.&lt;/li&gt;
&lt;li&gt;Watermark Offset: Point to the current writing space.
&lt;ul&gt;
&lt;li&gt;ID: SegmentID&lt;/li&gt;
&lt;li&gt;Offset: The offset in Segment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Writed Offset: Point to the latest refreshed data, that would be overridden by the write offset after period refresh.
&lt;ul&gt;
&lt;li&gt;ID: SegmentID&lt;/li&gt;
&lt;li&gt;Offset: The offset in Segment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reading Offset: Point to the current reading space.
&lt;ul&gt;
&lt;li&gt;ID: SegmentID&lt;/li&gt;
&lt;li&gt;Offset: The offset in Segment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Committed Offset: Point to the latest committed offset , that is equal to the latest acked offset plus one.
&lt;ul&gt;
&lt;li&gt;ID: SegmentID&lt;/li&gt;
&lt;li&gt;Offset: The offset in Segment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;meta.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The following diagram illustrates the transformation process.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The publisher receives data and wants to write to Queue.
&lt;ul&gt;
&lt;li&gt;The publisher would read Writing Offset to find a space and do plus one.&lt;/li&gt;
&lt;li&gt;After this, the publisher will write the data to the space.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The consumer wants to read the data from Queue.
&lt;ul&gt;
&lt;li&gt;The consumer would read Reading Offset to find the current read offset and do plus one.&lt;/li&gt;
&lt;li&gt;After this, the consumer will read the data from the space.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;On period flush, the flusher would override Watermark Offset by using Writing Offset.&lt;/li&gt;
&lt;li&gt;When the ack operation is triggered, Committed Offset would plus the batch size in the ack batch.&lt;/li&gt;
&lt;li&gt;When facing crash, Writing Offset and Reading Offset would be overridden by Watermark Offset and Committed Offset. That is because the Reading Offset and Writing Offset cannot guarantee at least once delivery.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;offset-convert.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;mmap-performance-test&#34;&gt;Mmap Performance Test&lt;/h6&gt;
&lt;p&gt;The test is to verify the efficiency of mmap in low memory cost.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The rate of data generation: 7.5K/item 1043 item/s (Based on Aifanfan online pod.)&lt;/li&gt;
&lt;li&gt;The test structure is based on &lt;a href=&#34;https://github.com/grandecola/bigqueue&#34;&gt;Bigqueue&lt;/a&gt; because of similar structure.&lt;/li&gt;
&lt;li&gt;Test tool: Go Benchmark Test&lt;/li&gt;
&lt;li&gt;Command: go test -bench BenchmarkEnqueue  -run=none -cpu=1&lt;/li&gt;
&lt;li&gt;Result On Mac(15-inch, 2018,16 GB 2400 MHz DDR4, 2.2 GHz Intel Core i7 SSD):
&lt;ul&gt;
&lt;li&gt;BenchmarkEnqueue/ArenaSize-128KB/MessageSize-8KB/MaxMem-384KB              66501             21606 ns/op              68 B/op          1 allocs/op&lt;/li&gt;
&lt;li&gt;BenchmarkEnqueue/ArenaSize-128KB/MessageSize-8KB/MaxMem-1.25MB             72348             16649 ns/op              67 B/op          1 allocs/op&lt;/li&gt;
&lt;li&gt;BenchmarkEnqueue/ArenaSize-128KB/MessageSize-16KB/MaxMem-1.25MB            39996             33199 ns/op             103 B/op          1 allocs/op&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Result On Linux(INTEL Xeon E5-2450 V2 8C 2.5GHZ&lt;em&gt;2,INVENTEC PC3L-10600 16G&lt;/em&gt;8,INVENTEC SATA 4T 7.2K*8):
&lt;ul&gt;
&lt;li&gt;BenchmarkEnqueue/ArenaSize-128KB/MessageSize-8KB/MaxMem-384KB         	  126662	     12070 ns/op	      62 B/op	       1 allocs/op&lt;/li&gt;
&lt;li&gt;BenchmarkEnqueue/ArenaSize-128KB/MessageSize-8KB/MaxMem-1.25MB        	  127393	     12097 ns/op	      62 B/op	       1 allocs/op&lt;/li&gt;
&lt;li&gt;BenchmarkEnqueue/ArenaSize-128KB/MessageSize-16KB/MaxMem-1.25MB       	   63292	     23806 ns/op	      92 B/op	       1 allocs/op&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Conclusion: Based on the above tests, mmap is both satisfied at the write speed and at little memory with very low consumption when running as a sidecar.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;processor&#34;&gt;Processor&lt;/h3&gt;
&lt;p&gt;The Processor has 3 core components, which are Consumer, Filter, and Context.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Consumer is created by the downstream Queue. The consumer has its own read offset and committed offset, which is similar to the offset concept of Spark Streaming.&lt;/li&gt;
&lt;li&gt;Due to the particularity of APM data preprocessing, Context is a unique concept in the Satellite filter chain, which supports storing the intermediate event because the intermediate state event also needs to be sent in sometimes.&lt;/li&gt;
&lt;li&gt;The Filter is the core data processing part, which is similar to the processor of &lt;a href=&#34;https://github.com/elastic/beats&#34;&gt;beats&lt;/a&gt;. Due to the context, the upstream/downstream filters would be logically coupling.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;Processor.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;sender&#34;&gt;Sender&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;BatchConverter decouples the Processor and Sender by staging the Buffer structure, providing parallelization. But if BatchBuffer is full, the downstream processors would be blocked.&lt;/li&gt;
&lt;li&gt;Follower is a real send worker that has a client, such as a gRPC client or Kafka client, and a fallback strategy. Fallback strategy is an interface, we can add more strategies to resolve the abnormal conditions, such as Instability in the network, upgrade the oap cluster.&lt;/li&gt;
&lt;li&gt;When sent success, Committed Offset in Queue would plus the number of this batch.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;Sender.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;high-performance&#34;&gt;High Performance&lt;/h3&gt;
&lt;p&gt;The scenario using Satellite is to collect a lot of APM data collection. We guarantee high performance by the following ways.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shorten transmission path, that means only join 2 components,which are Queue and Processor, between receiving and forwarding.&lt;/li&gt;
&lt;li&gt;High Performance Queue. MmapQueue provides a big, fast and persistent queue based on memory mapped file and ring structure.&lt;/li&gt;
&lt;li&gt;Processor maintains a linear design, that could be functional processed in one go-routine to avoid too much goroutines switching.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;stability&#34;&gt;Stability&lt;/h2&gt;
&lt;p&gt;Stability is a core point in Satellite. Stability can be considered in many ways, such as stable resources cost, stable running and crash recovery.&lt;/p&gt;
&lt;h3 id=&#34;stable-resource-cost&#34;&gt;Stable resource cost&lt;/h3&gt;
&lt;p&gt;In terms of resource cost,  Memory and CPU should be a concern.&lt;/p&gt;
&lt;p&gt;In the aspect of the CPU, we keep a sequence structure to avoid a large number of retries occurring when facing network congestion. And Satellite avoids keep pulling when the Queue is empty based on the offset design of Queue.&lt;/p&gt;
&lt;p&gt;In the aspect of the Memory, we have guaranteed only one data caching in Satellite, that is Queue. For the queue structure, we also keep the size fixed based on the ring structure to maintain stable Memory cost. Also, MmapQueue is designed for minimizing memory consumption and providing persistence while keeping speed as fast as possible. Maybe supports some strategy to dynamically control the size of MmapQueue to process more extreme conditions in the future.&lt;/p&gt;
&lt;h3 id=&#34;stable-running&#34;&gt;Stable running&lt;/h3&gt;
&lt;p&gt;There are many cases of network congestion, such as the network problem on the host node, OAP cluster is under upgrating, and Kafka cluster is unstable. When facing the above cases, Follower would process fallback strategy and block the downstream processes. Once the failure strategy is finished, such that send success or give up this batch, the Follower would process the next batch.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;Sender.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;crash-recovery&#34;&gt;Crash Recovery&lt;/h3&gt;
&lt;p&gt;The crash recovery only works when the user selects MmapQueue in Gatherer because of persistent file system design. When facing a crash, Reading Offset would be overridden by Committed Offset that ensure the at least once delivery. And Writed Offset would override Writing Offset that ensures the consumer always works properly and avoid encountering uncrossable defective data blocks.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;offset-convert.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;buffer-pool&#34;&gt;Buffer pool&lt;/h2&gt;
&lt;p&gt;The Queue is to store fixed structure objects, object buffer pool would be efficient to reuse memory to avoid GC.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ackChan&lt;/li&gt;
&lt;li&gt;batch convertor&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;some-metrics&#34;&gt;Some metrics&lt;/h2&gt;
&lt;p&gt;In Satellite, we should also collect its own monitoring metrics. The following metrics are necessary for Satellite.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cpu&lt;/li&gt;
&lt;li&gt;memory&lt;/li&gt;
&lt;li&gt;go routine number&lt;/li&gt;
&lt;li&gt;gatherer_writing_offset&lt;/li&gt;
&lt;li&gt;gatherer_watermark_offset&lt;/li&gt;
&lt;li&gt;processor_reading_count&lt;/li&gt;
&lt;li&gt;sender_committed_offset&lt;/li&gt;
&lt;li&gt;sender_abandoned_count&lt;/li&gt;
&lt;li&gt;sender_retry_count&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;input-and-output&#34;&gt;Input and Output&lt;/h2&gt;
&lt;p&gt;We will reuse this diagram to explain the input and output.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input
&lt;ul&gt;
&lt;li&gt;Because the push-pull mode is both supported, Queue is a core component.&lt;/li&gt;
&lt;li&gt;Queue is designed to be a ring-shaped fixed capacity, that means the oldest data would be overridden by the latest data. If users find data loss, users should raise the ceiling of memory Queue. MmapQueue generally doesn&amp;rsquo;t face this problem unless the Sender transport is congested.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ouput
&lt;ul&gt;
&lt;li&gt;If the BatchBuffer is full, the processor would be blocked.&lt;/li&gt;
&lt;li&gt;If the Channel is full, the downstream components would be blocked, such as BatchConvertor and Processor.&lt;/li&gt;
&lt;li&gt;When SenderWorker sends failure, the batch data would do a failure strategy that would block pulling data from the Channel. The strategy is a part of Sender,the operation mode is synchronous.&lt;/li&gt;
&lt;li&gt;Once the failure strategy is finished, such that send success or give up this batch, the Sendworker would keep pulling data from the Channel.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;detail-modules.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;
&lt;h3 id=&#34;how-to-avoid-keep-pulling-when-the-queue-is-empty&#34;&gt;How to avoid keep pulling when the Queue is empty?&lt;/h3&gt;
&lt;p&gt;If Watermark Offset is less than or equal to Reading Offset, a signal would be sent to the consumer to avoid keep pulling.&lt;/p&gt;
&lt;h3 id=&#34;why-reusing-files-in-queue&#34;&gt;Why reusing files in Queue?&lt;/h3&gt;
&lt;p&gt;The unified model  is a ring in Queue, that limits fixed resources cost  in memory or disk.In Mmap Queue, reusing files turns the delete operations into an overwrite operations, effectively reducing the creation and deletion behavior in files.&lt;/p&gt;
&lt;h3 id=&#34;what-are-the-strategies-for-file-creation-and-deletion-in-mmapqueue&#34;&gt;What are the strategies for file creation and deletion in MmapQueue?&lt;/h3&gt;
&lt;p&gt;As Satellite running, the number of the files in MmapQueue would keep growing until up to the maximum capacity. After this, the old files will be overridden by the new data to avoid file deletion. When the Pod died, all resources were recycled.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: [Video] Another backend storage solution for the APM system</title>
      <link>https://skywalking.apache.org/blog/2020-11-21-apachecon-obs-shardingsphere/</link>
      <pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-11-21-apachecon-obs-shardingsphere/</guid>
      <description>
        
        
        &lt;p&gt;The APM system provides the tracing or metrics for distributed systems or microservice architectures. Back to APM themselves, they always need backend storage to store the necessary massive data. What are the features required for backend storage? Simple, fewer dependencies, widely used query language, and the efficiency could be into your consideration. Based on that, traditional SQL databases (like MySQL) or NoSQL databases would be better choices. However, this topic will present another backend storage solution for the APM system viewing from NewSQL. Taking Apache Skywalking for instance, this talking will share how to make use of Apache ShardingSphere, a distributed database middleware ecosystem to extend the APM system&amp;rsquo;s storage capability.&lt;/p&gt;
&lt;p&gt;As a senior DBA worked at JD.com, the responsibility is to develop the distributed database and middleware, and the automated management platform for database clusters. As a PMC of Apache ShardingSphere, I am willing to contribute to the OS community and explore the area of distributed databases and NewSQL.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/OazS_3r3NM4&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Blog: [Video] Improve Apache APISIX observability with Apache SkyWalking</title>
      <link>https://skywalking.apache.org/blog/2020-11-21-apachecon-obs-apisix/</link>
      <pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-11-21-apachecon-obs-apisix/</guid>
      <description>
        
        
        &lt;p&gt;Apache APISIX is a cloud-native microservices API gateway, delivering the ultimate performance, security, open-source and scalable platform for all your APIs and microservices. Apache SkyWalking: an APM(application performance monitor) system, especially designed for microservices, cloud-native and container-based (Docker, Kubernetes, Mesos) architectures. Through the powerful plug-in mechanism of Apache APISIX, Apache Skywalking is quickly supported, so that we can see the complete life cycle of requests from the edge to the internal service. Monitor and manage each request in a visual way, and improve the observability of the service.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/DleVJwPs4i4&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Blog: [Video] SourceMarker - Continuous Feedback for Developers</title>
      <link>https://skywalking.apache.org/blog/2020-11-21-apachecon-obs-sourcemarker/</link>
      <pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-11-21-apachecon-obs-sourcemarker/</guid>
      <description>
        
        
        &lt;p&gt;Today&amp;rsquo;s monitoring solutions are geared towards operational tasks, displaying behavior as time-series graphs inside dashboards and other abstractions. These abstractions are immensely useful but are largely designed for software operators, whose responsibilities require them to think in systems, rather than the underlying source code. This is problematic given that an ongoing trend of software development is the blurring boundaries between building and operating software. This trend makes it increasingly necessary for programming environments to not just support development-centric activities, but operation-centric activities as well. Such is the goal of the feedback-driven development approach. By combining IDE and APM technology, software developers can intuitively explore multiple dimensions of their software simultaneously with continuous feedback about their software from inception to production.&lt;/p&gt;
&lt;p&gt;Brandon Fergerson is an open-source software developer who does not regard himself as a specialist in the field of programming, but rather as someone who is a devoted admirer. He discovered the beauty of programming at a young age and views programming as an art and those who do it well to be artists. He has an affinity towards getting meta and combining that with admiration of programming, has found source code analysis to be exceptionally interesting. Lately, his primary focus involves researching and building AI-based pair programming technology.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/IWounkxhfi0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Blog: [Video] The history of distributed tracing storage</title>
      <link>https://skywalking.apache.org/blog/2020-11-21-apachecon-obs-storage/</link>
      <pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-11-21-apachecon-obs-storage/</guid>
      <description>
        
        
        &lt;p&gt;Over the past few years, and coupled with the growing adoption of microservices, distributed tracing has emerged as one of the most commonly used monitoring and troubleshooting methodologies. New tracing tools are increasingly being introduced, driving adoption even further. One of these tools is Apache SkyWalking, a popular open-source tracing, and APM platform. This talk explores the history of the SkyWalking storage module, shows the evolution of distributed tracing storage layers, from the traditional relational database to document-based search engine. I hope that this talk contributes to the understanding of history and also that it helps to clarify the different types of storage that are available to organizations today.&lt;/p&gt;
&lt;p&gt;Hongtao Gao is the engineer of tetrate.io and the former Huawei Cloud expert. One of PMC members of Apache SkyWalking and participates in some popular open-source projects such as Apache ShardingSphere and Elastic-Job. He has an in-depth understanding of distributed databases, container scheduling, microservices, ServicMesh, and other technologies.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/iQ0tODBoh1k&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Blog: [Video] Apache grows in China</title>
      <link>https://skywalking.apache.org/blog/2020-11-21-apachecon-keynote/</link>
      <pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-11-21-apachecon-keynote/</guid>
      <description>
        
        
        &lt;p&gt;Sheng Wu is a founding engineer at tetrate.io, leads the observability for service mesh and hybrid cloud. A searcher, evangelist, and developer in the observability, distributed tracing, and APM. He is a member of the Apache Software Foundation. Love open source software and culture. Created the Apache SkyWalking project and being its VP and PMC member. Co-founder and PMC member of Apache ShardingSphere. Also as a PMC member of Apache Incubator and APISIX. He is awarded as Microsoft MVP, Alibaba Cloud MVP, Tencent Cloud TVP.&lt;/p&gt;
&lt;p&gt;In the Apache FY2020 report, China is on the top of the download statistics. More China initiated projects joined the incubator, and some of them graduated as the Apache TLP. Sheng joined the Apache community since 2017, in the past 3 years, he witnessed the growth of the open-source culture and Apache way in China.
Many developers have joined the ASF as new contributors, committers, foundation members. Chinese enterprises and companies paid more attention to open source contributions, rather than simply using the project like before. In the keynote, he would share the progress about China embracing the Apache culture, and willing of enhancing the whole Apache community.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/26aFGdbZvac&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Blog: Features in SkyWalking 8.2: Browser Side Monitoring; Query Traces by Tags; Meter Analysis Language</title>
      <link>https://skywalking.apache.org/blog/2020-10-29-skywalking8-2-release/</link>
      <pubDate>Thu, 29 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-10-29-skywalking8-2-release/</guid>
      <description>
        
        
        &lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl5m6kv3uj31lb0u0jum.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Author: Zhenxu Ke, Sheng Wu, Hongtao Gao, and Tevah Platt. tetrate.io&lt;/li&gt;
&lt;li&gt;Original link, &lt;a href=&#34;https://tetrate.io/blog/whats-new-with-apache-skywalking-8-2-browser-monitoring-and-more/&#34;&gt;Tetrate.io blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Oct. 29th, 2020&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apache SkyWalking, the observability platform, and open-source application performance monitor (APM) project, today announced the general availability of its 8.2 release. The release extends Apache SkyWalking’s functionalities and monitoring boundary to the browser side.&lt;/p&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;SkyWalking is an observability platform and APM tool that works with or without a service mesh, providing automatic instrumentation for microservices, cloud-native and container-based applications. The top-level Apache project is supported by a global community and is used by Alibaba, Huawei, Tencent, Baidu, ByteDance, and scores of others.&lt;/p&gt;
&lt;h2 id=&#34;browser-side-monitoring&#34;&gt;Browser side monitoring&lt;/h2&gt;
&lt;p&gt;APM helps SRE and Engineering teams to diagnose system failures, or optimize the systems before they become intolerably slow. But is it enough to always make the users happy?&lt;/p&gt;
&lt;p&gt;In 8.2.0, SkyWalking extends its monitoring boundary to the browser side, e.g., Chrome, or the network between Chrome and the backend service, or the codes running in the browser. With this, not only can we monitor the backend services and requests sent by the browser as usual, but also the front end rendering speed, error logs, etc., which are the most efficient metrics for capturing the experiences of our end users. (This does not currently extend to IoT devices, but this feature moves SkyWalking a step in that direction).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl5m71k6bj30zk0m8tdb.jpg&#34; alt=&#34;SkyWalking 8.2.0 Browser Side Monitoring: Overview&#34;&gt;&lt;/p&gt;
&lt;p&gt;What&amp;rsquo;s more, SkyWalking browser monitoring also provides data about how the users use products, such as PV(page views), UV(unique visitors), top N PV(page views), etc., which can give a product team clues for optimizing their products.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl5m5tld9j30zk0m843n.jpg&#34; alt=&#34;SkyWalking 8.2.0 Browser Side Monitoring: Pages&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;query-traces-by-tags&#34;&gt;Query traces by tags&lt;/h2&gt;
&lt;p&gt;In SkyWalking&amp;rsquo;s Span data model, there are many important fields that are already indexed and can be queried by the users, but for the sake of performance, querying by Span tags was not supported until now. In SkyWalking 8.2.0, we allow users to query traces by specified tags, which is extremely useful. For example, SRE engineers running tests on the product environment can tag the synthetic traffic and query by this tag later.&lt;/p&gt;
&lt;h2 id=&#34;meter-analysis-language&#34;&gt;Meter Analysis Language&lt;/h2&gt;
&lt;p&gt;In 8.2.0, the meter system provides a functional analysis language called MAL(Meter Analysis Language) that allows users to analyze and aggregate meter data in the OAP streaming system. The result of an expression can be ingested by either the agent analyzer or OpenTelemetry/Prometheus analyzer.&lt;/p&gt;
&lt;h2 id=&#34;composite-alert-rules&#34;&gt;Composite Alert Rules&lt;/h2&gt;
&lt;p&gt;Alerting is a good way to discover system failures in time. A common problem is that we configure too many triggers just to avoid missing any possible issue. Nobody likes to be woken up by alert messages at midnight, only to find out that the trigger is too sensitive. These kinds of alerts become noisy and don&amp;rsquo;t help at all.&lt;/p&gt;
&lt;p&gt;In 8.2.0, users can now configure composite alert rules, where composite rules take multiple metrics dimensions into account. With composite alert rules, we can leverage as many metrics as needed to more accurately determine whether there’s a real problem or just an occasional glitch.&lt;/p&gt;
&lt;p&gt;Common scenarios like &lt;code&gt;successful rate &amp;lt; 90% but there are only 1~2 requests&lt;/code&gt; can now be resolved by a composite rule, such as &lt;code&gt;traffic(calls per minute) &amp;gt; n &amp;amp;&amp;amp; successful rate &amp;lt; m%&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;other-notable-enhancements&#34;&gt;Other Notable Enhancements&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;The agent toolkit exposes some APIs for users to send customizable metrics.&lt;/li&gt;
&lt;li&gt;The agent &lt;code&gt;exclude_plugins&lt;/code&gt; allows you to exclude some plugins; &lt;code&gt;mount&lt;/code&gt; enables you to load a new set of plugins.&lt;/li&gt;
&lt;li&gt;More than 10 new plugins have been contributed to the agent.&lt;/li&gt;
&lt;li&gt;The alert system natively supports sending alert messages to Slack, WeChat, DingTalk.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;additional-resources&#34;&gt;Additional Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Read more about the &lt;a href=&#34;https://github.com/apache/skywalking/blob/v8.2.0/CHANGES.md&#34;&gt;SkyWalking 8.2 release highlights&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Get more SkyWalking updates on &lt;a href=&#34;https://twitter.com/ASFSkyWalking&#34;&gt;Twitter&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Observability at Scale: SkyWalking it is</title>
      <link>https://skywalking.apache.org/blog/2020-08-11-observability-at-scale/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-08-11-observability-at-scale/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;Author: Sheng Wu&lt;/li&gt;
&lt;li&gt;Original link, &lt;a href=&#34;https://www.tetrate.io/blog/observability-at-scale-skywalking-it-is/&#34;&gt;Tetrate.io blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SkyWalking, a top-level Apache project, is the open source APM and observability analysis platform that is solving the problems of 21st-century systems that are increasingly large, distributed, and heterogenous. It&amp;rsquo;s built for the struggles system admins face today: To identify and locate needles in a haystack of interdependent services, to get apples-to-apples metrics across polyglot apps, and to get a complete and meaningful view of performance.&lt;/p&gt;
&lt;p&gt;SkyWalking is a holistic platform that can observe microservices on or off a mesh, and can provide consistent monitoring with a lightweight payload.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a look at how SkyWalking evolved to address the problem of observability at scale, and grew from a pure tracing system to a feature-rich observability platform that is now used to analyze deployments that collect tens of billions of traces per day.&lt;/p&gt;
&lt;h3 id=&#34;designing-for-scale&#34;&gt;Designing for scale&lt;/h3&gt;
&lt;p&gt;When SkyWalking was first initialized back in 2015, its primary use case was monitoring the first-generation distributed core system of China Top Telecom companies, China Unicom and China Mobile. In 2013-2014, the telecom companies planned to replace their old traditional monolithic applications with a distributed system. Supporting a super-large distributed system and scaleablity were the high-priority design goals from Day one. So, what matters at scale?&lt;/p&gt;
&lt;h3 id=&#34;pull-vs-push&#34;&gt;Pull vs. push&lt;/h3&gt;
&lt;p&gt;Pull and push modes relate to the direction of data flow. If the agent collects data and pushes them to the backend for further analysis, we call it &amp;ldquo;push&amp;rdquo; mode. Debate over pull vs. push has gone on for a long time. The key for an observability system is to minimize the cost of the agent, and to be generally suitable for different kinds of observability data.&lt;/p&gt;
&lt;p&gt;The agent would send the data out a short period after it is collected. Then, we would have less concern about overloading the local cache. One typical case would be endpoint (URI of HTTP, service of gRPC) metrics. Any service could easily have hundreds, even thousands of endpoints. An APM system must have these metrics analysis capabilities.&lt;/p&gt;
&lt;p&gt;Furthermore, metrics aren&amp;rsquo;t the only thing in the observability landscape; traces and logs are important too. SkyWalking is designed to provide a 100% sampling rate tracing capability in the production environment. Clearly, push mode is the only solution.&lt;/p&gt;
&lt;p&gt;At the same time, using push mode natively doesn&amp;rsquo;t mean SkyWalking can&amp;rsquo;t do data pulling. In recent 8.x releases, SkyWalking supports fetching data from Prometheus-instrumented services for reducing the Non-Recurring Engineering of the end users. Also, pull mode is popular in the MQ based transport, typically as a Kafka consumer. The SkyWalking agent side uses the push mode, and the OAP server uses the pull mode.&lt;/p&gt;
&lt;p&gt;The conclusion: push mode is the native way, but pull mode works in some special cases too.&lt;/p&gt;
&lt;h3 id=&#34;metrics-analysis-isnt-just-mathematical-calculation&#34;&gt;Metrics analysis isn&amp;rsquo;t just mathematical calculation&lt;/h3&gt;
&lt;p&gt;Metrics rely on mathematical theories and calculations. Percentile is a good measure for identifying the long tail issue, and reasonable average response time and successful rate are good SLO(s). But those are not all. Distributed tracing provides not just traces with detailed information, but high values metrics that can be analyzed.&lt;/p&gt;
&lt;p&gt;The service topology map is required from Ops and SRE teams for the NOC dashboard and confirmation of system data flow. SkyWalking uses the &lt;a href=&#34;https://wu-sheng.github.io/STAM/&#34;&gt;STAM (Streaming Topology Analysis Method)&lt;/a&gt; to analyze topology from the traces, or based on ALS (Envoy Access Log Service) in the service mesh environment. This topology and metrics of nodes (services) and lines (service relationships) can&amp;rsquo;t be pulled from simple metrics SDKs.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;topology-v8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;As with fixing the limitation of endpoint metrics collection, SkyWalking needs to do endpoint dependency analysis from trace data too. Endpoint dependency analysis provides more important and specific information, including upstream and downstream. Those dependency relationships and metrics help the developer team to locate the boundaries of a performance issue, to specific code blocks.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;endpoint-dependency-v8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;pre-calculation-vs-query-stage-calculation&#34;&gt;Pre-calculation vs. query stage calculation?&lt;/h3&gt;
&lt;p&gt;Query stage calculation provides flexibility. Pre-calculation, in the analysis stage, provides better and much more stable performance. Recall our design principle: SkyWalking targets a large-scale distributed system. Query stage calculation was very limited in scope, and most metrics calculations need to be pre-defined and pre-calculated. The key of supporting large datasets is reducing the size of datasets in the design level. Pre-calculation allows the original data to be merged into aggregated results downstream, to be used in a query or even for an alert check.&lt;/p&gt;
&lt;p&gt;TTL of metrics is another important business enabler. With the near linear performance offered by queries because of pre-calculation, with a similar query infrastructure, organizations can offer higher TTL, thereby providing extended visibility of performance.&lt;/p&gt;
&lt;p&gt;Speaking of alerts, query-stage calculation also means the alerting query is required to be based on the query engine. But in this case, when the dataset increasing, the query performance could be inconsistent. The same thing happens in a different metrics query.&lt;/p&gt;
&lt;h3 id=&#34;cases-today&#34;&gt;Cases today&lt;/h3&gt;
&lt;p&gt;Today, SkyWalking is monitoring super large-scale distributed systems in many large enterprises, including Alibaba, Huawei, Tencent, Baidu, China Telecom, and various banks and insurance companies. The online service companies have more traffic than the traditional companies, like banks and telecom suppliers.&lt;/p&gt;
&lt;p&gt;SkyWalking is the observability platform used for a variety of use cases for distributed systems that are super-large by many measures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lagou.com, an online job recruitment platform
&lt;ul&gt;
&lt;li&gt;SkyWalking is observing &amp;gt;100 services, 500+ JVM instances&lt;/li&gt;
&lt;li&gt;SkyWalking collects and analyzes 4+ billion traces per day to analyze performance data, including metrics of 300k+ endpoints and dependencies&lt;/li&gt;
&lt;li&gt;Monitoring &amp;gt;50k traffic per second in the whole cluster&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Yonghui SuperMarket, online service
&lt;ul&gt;
&lt;li&gt;SkyWalking analyzes at least 10+ billion (3B) traces with metrics per day&lt;/li&gt;
&lt;li&gt;SkyWalking&amp;rsquo;s second, smaller deployment, analyzes 200+ million traces per day&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Baidu, internet and AI company, Kubernetes deployment
&lt;ul&gt;
&lt;li&gt;SkyWalking collects 1T+ traces a day from 1,400+ pods of 120+ services&lt;/li&gt;
&lt;li&gt;Continues to scale out as more services are added&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Beike Zhaofang(ke.com), a Chinese online property brokerage backed by Tencent Holdings and SoftBank Group
&lt;ul&gt;
&lt;li&gt;Has used SkyWalking from its very beginning, and has two members in the PMC team.&lt;/li&gt;
&lt;li&gt;Deployments collect 16+ billion traces per day&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ali Yunxiao, DevOps service on the Alibaba Cloud,
&lt;ul&gt;
&lt;li&gt;SkyWalking collects and analyzes billions of spans per day&lt;/li&gt;
&lt;li&gt;SkyWalking keeps AliCloud&amp;rsquo;s 45 services and ~300 instances stable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A department of Alibaba TMall, one of the largest business-to-consumer online retailers, spun off from Taobao
&lt;ul&gt;
&lt;li&gt;A customized version of SkyWalking monitors billions of traces per day&lt;/li&gt;
&lt;li&gt;At the same time, they are building a load testing platform based on SkyWalking&amp;rsquo;s agent tech stack, leveraging its tracing and context propagation cabilities&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;SkyWalking&amp;rsquo;s approach to observability follows these principles:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Understand the logic model: don&amp;rsquo;t treat observability as a mathematical tool.&lt;/li&gt;
&lt;li&gt;Identify dependencies first, then their metrics.&lt;/li&gt;
&lt;li&gt;Scaling should be accomplished easily and natively.&lt;/li&gt;
&lt;li&gt;Maintain consistency across different architectures, and in the performance of APM itself.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;resources&#34;&gt;Resources&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Read about the &lt;a href=&#34;https://github.com/apache/skywalking/blob/master/CHANGES.md&#34;&gt;SkyWalking 8.1 release highlights&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Get more SkyWalking updates on &lt;a href=&#34;https://twitter.com/asfskywalking?lang=en&#34;&gt;Twitter&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Sign up to hear more about SkyWalking and observability from &lt;a href=&#34;https://www.tetrate.io/contact-us/&#34;&gt;Tetrate&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Features in SkyWalking 8.1: SpringSleuth metrics, endpoint dependency detection, Kafka transport traces and metrics</title>
      <link>https://skywalking.apache.org/blog/2020-08-03-skywalking8-1-release/</link>
      <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-08-03-skywalking8-1-release/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;Author: Sheng Wu, Hongtao Gao, and Tevah Platt(Tetrate)&lt;/li&gt;
&lt;li&gt;Original link, &lt;a href=&#34;https://www.tetrate.io/blog/skywalking8-1-release/&#34;&gt;Tetrate.io blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;apache-skywalking.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Apache SkyWalking, the observability platform, and open-source application performance monitor (APM) project, today announced the general availability of its 8.1 release that extends its functionalities and provides a transport layer to maintain the lightweight of the platform that observes data continuously.&lt;/p&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;SkyWalking is an observability platform and APM tool that works with or without a service mesh, providing automatic instrumentation for microservices, cloud-native and container-based applications. The top-level Apache project is supported by a global community and is used by Alibaba, Huawei, Tencent, Baidu, and scores of others.&lt;/p&gt;
&lt;h2 id=&#34;transport-traces&#34;&gt;Transport traces&lt;/h2&gt;
&lt;p&gt;For a long time, SkyWalking has used gRPC and HTTP to transport traces, metrics, and logs. They provide good performance and are quite lightweight, but people kept asking about the MQ as a transport layer because they want to keep the observability data continuously as much as possible. From SkyWalking’s perspective, the MQ based transport layer consumes more resources required in the deployment and the complexity of deployment and maintenance but brings more powerful throughput capacity between the agent and backend.&lt;/p&gt;
&lt;p&gt;In 8.1.0, SkyWalking officially provides the typical MQ implementation, Kafka, to transport all observability data, including traces, metrics, logs, and profiling data. At the same time, the backend can support traditional gRPC and HTTP receivers, with the new Kafka consumer at the same time. Different users could choose the transport layer(s) according to their own requirements. Also, by referring to this &lt;a href=&#34;https://github.com/apache/skywalking/pull/4847&#34;&gt;implementation&lt;/a&gt;, the community could contribute various transport plugins for Apache Pulsar, RabbitMQ.&lt;/p&gt;
&lt;h2 id=&#34;automatic-endpoint-dependencies-detection&#34;&gt;Automatic endpoint dependencies detection&lt;/h2&gt;
&lt;p&gt;The 8.1 SkyWalking release offers automatic detection of endpoint dependencies. SkyWalking has long offered automatic endpoint detection, but endpoint dependencies, including upstream and downstream endpoints, are critical for Ops and SRE teams’ performance analysis. The APM system is expected to detect the relationships powered by the distributed tracing. While SkyWalking has been designed to include this important information at the beginning the latest 8.1 release offers a cool visualization about the dependency and metrics between dependent endpoints. It provides a new drill-down angle from the topology. Once you have the performance issue from the service level, you could check on instance and endpoint perspectives:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;endpoint-dep.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;springsleuth-metrics-detection&#34;&gt;SpringSleuth metrics detection&lt;/h2&gt;
&lt;p&gt;In the Java field, the Spring ecosystem is one of the most widely used. &lt;a href=&#34;https://micrometer.io/&#34;&gt;Micrometer&lt;/a&gt;, the metrics API lib included in the Spring Boot 2.0, is now adopted by SkyWalking’s native meter system APIs and agent. For applications using Micrometer with the SkyWalking agent installed, all Micrometer collected metrics could then be shipped into SkyWalking OAP. With &lt;a href=&#34;https://github.com/apache/skywalking/blob/master/docs/en/setup/backend/spring-sleuth-setup.md&#34;&gt;some configurations in the OAP and UI&lt;/a&gt;, all metrics are analyzed and visualized in the SkyWalking UI, with all other metrics detected by SkyWalking agents automatically.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;spring.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;notable-enhancements&#34;&gt;Notable enhancements&lt;/h2&gt;
&lt;p&gt;The Java agent core is enhanced in this release. It could work better in the concurrency class loader case and is more compatible with another agent solution, such as Alibaba’s Arthas.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;With the logic endpoint supported, the local span can be analyzed to get metrics. One span could carry the raw data of more than one endpoint’s performance.&lt;/li&gt;
&lt;li&gt;GraphQL, InfluxDB Java Client, and Quasar fiber libs are supported to be observed automatically.&lt;/li&gt;
&lt;li&gt;Kubernetes Configmap can now for the first time be used as the dynamic configuration center– a more cloud-native solution for k8s deployment environments.&lt;/li&gt;
&lt;li&gt;OAP supports health checks, especially including the storage health status. If the storage (e.g., ElasticSearch) is not available, you could get the unhealth status with explicit reasons through the health status query.&lt;/li&gt;
&lt;li&gt;Opencensus receiver supports ingesting OpenTelemetry/OpenCensus agent metrics by meter-system.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;additional-resources&#34;&gt;Additional resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Read more about the &lt;a href=&#34;https://github.com/apache/skywalking/blob/v8.1.0/CHANGES.md&#34;&gt;SkyWalking 8.1 release highlights&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Read more about SkyWalking from Tetrate on our &lt;a href=&#34;https://www.tetrate.io/blog/category/open-source/apache-skywalking/&#34;&gt;blog&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Get more SkyWalking updates on &lt;a href=&#34;https://twitter.com/ASFSkyWalking&#34;&gt;Twitter&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Sign up to hear more about SkyWalking and observability from &lt;a href=&#34;https://www.tetrate.io/contact-us/&#34;&gt;Tetrate&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: The Apdex Score for Measuring Service Mesh Health</title>
      <link>https://skywalking.apache.org/blog/2020-07-26-apdex-and-skywalking/</link>
      <pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-07-26-apdex-and-skywalking/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;Author: Srinivasan Ramaswamy, tetrate&lt;/li&gt;
&lt;li&gt;Original link, &lt;a href=&#34;https://www.tetrate.io/blog/the-apdex-score-for-measuring-service-mesh-health/&#34;&gt;Tetrate.io blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;asking-how-are-you-is-more-profound-than-what-are-your-symptoms&#34;&gt;Asking &lt;code&gt;How are you&lt;/code&gt; is more profound than &lt;code&gt;What are your symptoms&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;intro_image.png&#34; alt=&#34;alt_text&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;background&#34;&gt;&lt;strong&gt;Background&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Recently I visited my preferred doctor. Whenever I visit, the doctor greets me with a series of light questions: How’s your day? How about the week before? Any recent trips? Did I break my cycling record? How’s your workout regimen? _Finally _he asks, “Do you have any problems?&amp;rdquo;  On those visits when I didn&amp;rsquo;t feel ok, I would say something like, &amp;ldquo;&lt;em&gt;I&amp;rsquo;m feeling dull this week, and I&amp;rsquo;m feeling more tired towards noon….&amp;quot;&lt;/em&gt; It&amp;rsquo;s at this point that he takes out his stethoscope, his pulse oximeter, and blood pressure apparatus. Then, if he feels he needs a more in-depth insight, he starts listing out specific tests to be made.&lt;/p&gt;
&lt;p&gt;When I asked him if the first part of the discussion was just an ice-breaker, he said, &amp;ldquo;&lt;em&gt;That&amp;rsquo;s the essential part. It helps me find out how you feel, rather than what your symptoms are.&amp;quot;&lt;/em&gt; So, despite appearances, our opening chat about life helped him structure subsequent questions on symptoms, investigations and test results.&lt;/p&gt;
&lt;p&gt;On the way back, I couldn&amp;rsquo;t stop asking myself, &lt;em&gt;&amp;ldquo;Shouldn&amp;rsquo;t we be managing our mesh this way, too?&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If I strike parallels between my own health check and a  health check, “tests” would be log analysis, “investigations” would be tracing, and “symptoms” would be the traditional RED (Rate, Errors and Duration) metrics. That leaves the “essential part,” which is what we are talking about here: the &lt;em&gt;Wellness Factor&lt;/em&gt;, primarily the health of our mesh.&lt;/p&gt;
&lt;h3 id=&#34;health-in-the-context-of-service-mesh&#34;&gt;&lt;strong&gt;Health in the context of service mesh&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;We can measure the performance of any observed service through RED metrics.  RED metrics offer immense value in understanding the performance, reliability, and throughput of every service. Compelling visualizations of these metrics across the mesh make monitoring the entire mesh standardized and scalable. Also, setting alerts based on thresholds for each of these metrics helps to detect anomalies as and when they arise.&lt;/p&gt;
&lt;p&gt;To establish the context of any service and observe them, it&amp;rsquo;s ideal to visualize the mesh as a topology.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mesh-1.png&#34; alt=&#34;alt_text&#34;&gt;&lt;/p&gt;
&lt;p&gt;A topology visualization of the mesh not only allows for picking any service and watching its metrics, but also gives vital information about service dependencies and the potential impact of a given service on the mesh.&lt;/p&gt;
&lt;p&gt;While RED metrics of each service offer tremendous insights, the user is more concerned with the overall responsiveness of the mesh rather than each of these services in isolation.&lt;/p&gt;
&lt;p&gt;To describe the performance of any service, right from submitting the request to receiving a completed http response, we’d be measuring the user&amp;rsquo;s perception of responsiveness. This measure of response time compared with a set threshold is called Apdex. This Apdex is an indicator of the health of a service in the mesh.&lt;/p&gt;
&lt;h3 id=&#34;apdex&#34;&gt;&lt;strong&gt;Apdex&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Apdex is a measure of response time considered against a set threshold**.  **It is the ratio of satisfactory response times and unsatisfactory response times to total response times.&lt;/p&gt;
&lt;p&gt;Apdex is an industry standard to measure the satisfaction of users based on the response time of applications and services. It measures how satisfied your users are with your services, as traditional metrics such as average response time could get skewed quickly.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Satisfactory response time&lt;/em&gt; indicates the number of times when the roundtrip response time of a particular service was less than this threshold. &lt;em&gt;Unsatisfactory response time&lt;/em&gt; while meaning the opposite, is further categorized as &lt;em&gt;Tolerating&lt;/em&gt; and &lt;em&gt;Frustrating&lt;/em&gt;. &lt;em&gt;Tolerating&lt;/em&gt; accommodates any performance that is up to four times the threshold, and anything over that or any errors encountered is considered &lt;em&gt;Frustrating&lt;/em&gt;. The threshold mentioned here is an ideal roundtrip performance that we expect from any service. We could even start with an organization-wide limit of say, 500ms.&lt;/p&gt;
&lt;p&gt;The Apdex score is a ratio of satisfied and tolerating requests to the total requests made.&lt;/p&gt;
&lt;p&gt;Each &lt;em&gt;satisfied request&lt;/em&gt; counts as one request, while each &lt;em&gt;tolerating request&lt;/em&gt; counts as half a  &lt;em&gt;satisfied request&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;An Apdex score takes values from 0 to 1, with 0 being the worst possible score indicating that users were always frustrated, and ‘1’ as the best possible score (100% of response times were Satisfactory).&lt;/p&gt;
&lt;p&gt;A percentage representation of this score also serves as the Health Indicator of the service.&lt;/p&gt;
&lt;h2 id=&#34;the-math&#34;&gt;&lt;strong&gt;The Math&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The actual computation of this Apdex score is achieved through the following formula.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		            SatisfiedCount +  ( ToleratingCount / 2 )

Apdex Score  =  ------------------------------------------------------

                                TotalSamples
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A percentage representation of this score is known as the Health Indicator of a service.&lt;/p&gt;
&lt;h3 id=&#34;example-computation&#34;&gt;&lt;strong&gt;Example Computation&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;During a 2-minute period, a host handles 200 requests.&lt;/p&gt;
&lt;p&gt;The Apdex threshold T = 0.5 seconds (500ms).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;170 of the requests were handled within 500ms, so they are classified as Satisfied.&lt;/li&gt;
&lt;li&gt;20 of the requests were handled between 500ms and 2 seconds (2000 ms), so they are classified as Tolerating.&lt;/li&gt;
&lt;li&gt;The remaining 10 were not handled properly or took longer than 2 seconds, so they are classified as Frustrated.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The resulting Apdex score is 0.9:  (170 + (20/2))/200 = 0.9.&lt;/p&gt;
&lt;h3 id=&#34;the-next-level&#34;&gt;&lt;strong&gt;The next level&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;At the next level, we can attempt to improve our topology visualization by coloring nodes based on their health. Also, we can include health as a part of the information we show when the user taps on a service.&lt;/p&gt;
&lt;p&gt;Apdex specifications recommend the following Apdex Quality Ratings by classifying Apdex Score as Excellent (0.94 - 1.00), Good (0.85 - 0.93), Fair (0.70 - 0.84), Poor (0.50 - 0.69)  and Unacceptable (0.00 - 0.49).&lt;/p&gt;
&lt;p&gt;To visualize this, let’s look at our topology using traffic light colors, marking our  nodes as  Healthy,  At-Risk and  Unhealthy, where &lt;strong&gt;Unhealthy&lt;/strong&gt; indicates health that falls below 80%. A rate between 80% and 95% indicates &lt;strong&gt;At-Risk&lt;/strong&gt;, and health at 95% and above is termed &lt;strong&gt;Healthy&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let’s incorporate this coloring into our topology visualization and take its usability to the next level. If implemented, we will be looking at something like this.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mesh-2.png&#34; alt=&#34;alt_text&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;moving-further&#34;&gt;&lt;strong&gt;Moving further&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Apdex provides tremendous visibility into customer satisfaction on the responsiveness of our services. Even more, by extending the implementation to the edges calling this service we get further insight into the health of the mesh itself.&lt;/p&gt;
&lt;p&gt;Two services with similar Apdex scores offer the same customer satisfaction to the customer. However, the size of traffic that flows into the service can be of immense help in prioritizing between services to address. A service with higher traffic flow is an indication that this experience is impacting a significant number of users on the mesh.&lt;/p&gt;
&lt;p&gt;While health relates to a service, we can also analyze the interactions between two services and calculate the health of the interaction. This health calculation of every interaction on the mesh helps us establish a critical path, based on the health of all interactions in the entire topology.&lt;/p&gt;
&lt;p&gt;In a big mesh, showing traffic as yet another number will make it more challenging to visualize and monitor. We can, with a bit of creativity, improve the entire visualization by rendering the edges that connect services with different thickness depending on the throughput of the service.&lt;/p&gt;
&lt;p&gt;An unhealthy service participating in a high throughput transaction could lead to excessive consumption of resources. On the other hand, this visualization also offers a great tip to maximize investment in tuning services.&lt;/p&gt;
&lt;p&gt;Tuning service that is a part of a high throughput transaction offers exponential benefits when compared to tuning an occasionally used service.&lt;/p&gt;
&lt;p&gt;If we look at implementing such a visualization, which includes the health of interactions and throughput of such interactions, we would be looking at something like below :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mesh-4.png&#34; alt=&#34;alt_text&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;the-day-is-not-far&#34;&gt;&lt;strong&gt;The day is not far&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;These capabilities are already available to users &lt;strong&gt;today&lt;/strong&gt; as one of the UI features of Tetrate’s service mesh platform, using the highly configurable and performant observability and performance management framework: Apache SkyWalking (&lt;a href=&#34;https://skywalking.apache.org/&#34;&gt;https://skywalking.apache.org&lt;/a&gt;), which monitors traffic across the mesh, aggregates RED metrics for both services and their interactions, continuously computes and monitors health of the services, and enables users to configure alerts and notifications when services cross specific thresholds, thereby having a comprehensive health visibility of the mesh.&lt;/p&gt;
&lt;p&gt;With such tremendous visibility into our mesh performance, the day is not far when we at our NOC (Network Operations Center) for the mesh have this topology as our HUD (Heads Up Display).&lt;/p&gt;
&lt;p&gt;This HUD, with the insights and patterns gathered over time, would predict situations and proactively prompt us on potential focus areas to improve customer satisfaction.&lt;/p&gt;
&lt;p&gt;The visualization with rich historical data can also empower the Network Engineers to go back in time and look at the performance of the mesh on a similar day in the past.&lt;/p&gt;
&lt;p&gt;An earnest implementation of such a visualization would be something like below :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;mesh-5.png&#34; alt=&#34;alt_text&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;to-conclude&#34;&gt;&lt;strong&gt;To conclude&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;With all the discussion so far, the health of a mesh is more about how our users feel, and what we can proactively do as service providers to sustain, if not enhance, the experience of our users.&lt;/p&gt;
&lt;p&gt;As the world advances toward personalized medicine, we&amp;rsquo;re not far from a day when my doctor will text me: &amp;ldquo;How about feasting yourself with ice cream today and take the Gray Butte Trail to Mount Shasta!&amp;rdquo; Likewise, we can do more for our customers by having better insight into their overall wellness.&lt;/p&gt;
&lt;p&gt;Tetrate’s approach to “service mesh health” is not only to offer management, monitoring and support but to make infrastructure healthy from the start to reduce the probability of incidents.  Powered by the Istio, Envoy, and SkyWalking, Tetrate&amp;rsquo;s solutions enable consistent end-to-end observability, runtime security, and traffic management for any workload in any environment.&lt;/p&gt;
&lt;p&gt;Our customers deserve healthy systems! Please do share your thoughts on making service mesh an exciting and robust experience for our customers.&lt;/p&gt;
&lt;h3 id=&#34;references&#34;&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Apdex&#34;&gt;https://en.wikipedia.org/wiki/Apdex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.apdex.org/overview.html&#34;&gt;https://www.apdex.org/overview.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.apdex.org/index.php/specifications/&#34;&gt;https://www.apdex.org/index.php/specifications/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://skywalking.apache.org/&#34;&gt;https://skywalking.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Apache SkyWalking: Use Profiling to Fix the Blind Spot of Distributed Tracing</title>
      <link>https://skywalking.apache.org/blog/2020-04-13-apache-skywalking-profiling/</link>
      <pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-04-13-apache-skywalking-profiling/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;This post originally appears on &lt;a href=&#34;https://thenewstack.io/apache-skywalking-use-profiling-to-fix-the-blind-spot-of-distributed-tracing/&#34;&gt;The New Stack&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This post introduces a way to automatically profile code in production with &lt;a href=&#34;https://skywalking.apache.org&#34;&gt;Apache SkyWalking&lt;/a&gt;. We believe the profile method helps reduce maintenance and overhead while increasing the precision in root cause analysis.&lt;/p&gt;
&lt;h3 id=&#34;limitations-of-the-distributed-tracing&#34;&gt;Limitations of the Distributed Tracing&lt;/h3&gt;
&lt;p&gt;In the early days, metrics and logging systems were the key solutions in monitoring platforms. With the adoption of microservice and distributed system-based architecture, distributed tracing has become more important. Distributed tracing provides relevant service context, such as system topology map and RPC parent-child relationships.&lt;/p&gt;
&lt;p&gt;Some claim that distributed tracing is the best way to discover the cause of performance issues in a distributed system. It’s good at finding issues at the RPC abstraction, or in the scope of components instrumented with spans. However, it isn’t that perfect.&lt;/p&gt;
&lt;p&gt;Have you been surprised to find a span duration longer than expected, but no insight into why? What should you do next? Some may think that the next step is to add more instrumentation, more spans into the trace, thinking that you would eventually find the root cause, with more data points. We’ll argue this is not a good option within a production environment. Here’s why:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There is a risk of application overhead and system overload. Ad-hoc spans measure the performance of specific scopes or methods, but picking the right place can be difficult. To identify the precise cause, you can “instrument” (add spans to) many suspicious places. The additional instrumentation costs more CPU and memory in the production environment. Next, ad-hoc instrumentation that didn’t help is often forgotten, not deleted. This creates a valueless overhead load. In the worst case, excess instrumentation can cause performance problems in the production app or overload the tracing system.&lt;/li&gt;
&lt;li&gt;The process of ad-hoc (manual) instrumentation usually implies at least a restart. Trace instrumentation libraries, like Zipkin Brave, are integrated into many framework libraries. To instrument a method’s performance typically implies changing code, even if only an annotation. This implies a re-deploy. Even if you have the way to do auto instrumentation, like Apache SkyWalking, you still need to change the configuration and reboot the app. Otherwise, you take the risk of GC caused by hot dynamic instrumentation.&lt;/li&gt;
&lt;li&gt;Injecting instrumentation into an uninstrumented third party library is hard and complex. It takes more time and many won’t know how to do this.&lt;/li&gt;
&lt;li&gt;Usually, we don’t have code line numbers in the distributed tracing. Particularly when lambdas are in use, it can be difficult to identify the line of code associated with a span.
Regardless of the above choices, to dive deeper requires collaboration with your Ops or SRE team, and a shared deep level of knowledge in distributed tracing.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Regardless of the above choices, to dive deeper requires collaboration with your Ops or SRE team, and a shared deep level of knowledge in distributed tracing.&lt;/p&gt;
&lt;h3 id=&#34;profiling-in-production&#34;&gt;Profiling in Production&lt;/h3&gt;
&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;
&lt;p&gt;To reuse distributed tracing to achieve method scope precision requires an understanding of the above limitations and a different approach. We called it PROFILE.&lt;/p&gt;
&lt;p&gt;Most high-level languages build and run on a thread concept. The profile approach takes continuous thread dumps. We merge the thread dumps to estimate the execution time of every method shown in the thread dumps. The key for distributed tracing is the tracing context, identifiers active (or current) for the profiled method. Using this trace context, we can weave data harvested from profiling into existing traces. This allows the system to automate otherwise ad-hoc instrumentation. Let’s dig deeper into how profiling works:&lt;/p&gt;
&lt;p&gt;We consider a method invocation with the same stack depth and signature (method, line number etc), the same operation. We derive span timestamps from the thread dumps the same operation is in. Let’s put this visually:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;skywalking-blindspot-1.png&#34; alt=&#34;span timespaces&#34;&gt;&lt;/p&gt;
&lt;p&gt;Above, represents 10 successive thread dumps. If this method is in dumps 4-8, we assume it started before dump 4 and finished after dump 8. We can’t tell exactly when the method started and stopped. but the timestamps of thread dumps are close enough.&lt;/p&gt;
&lt;p&gt;To reduce overhead caused by thread dumps, we only profile methods enclosed by a specific entry point, such as a URI or MVC Controller method. We identify these entry points through the trace context and the APM system.&lt;/p&gt;
&lt;p&gt;The profile does thread dump analysis and gives us:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The root cause, precise to the line number in the code.&lt;/li&gt;
&lt;li&gt;Reduced maintenance as ad-hoc instrumentation is obviated.&lt;/li&gt;
&lt;li&gt;Reduced overload risk caused by ad-hoc instrumentation.&lt;/li&gt;
&lt;li&gt;Dynamic activation: only when necessary and with a very clear profile target.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;implementing-precise-profiling-with-apache-skywalking-7&#34;&gt;Implementing Precise Profiling with Apache SkyWalking 7&lt;/h3&gt;
&lt;p&gt;Distributed profiling is built-into Apache SkyWalking application performance monitoring (APM). Let’s demonstrate how the profiling approach locates the root cause of the performance issue.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final CountDownLatchcountDownLatch= new CountDownLatch(2);
 
threadPool.submit(new Task1(countDownLatch));
threadPool.submit(new Task2(countDownLatch));
 
try {
   countDownLatch.await(500, TimeUnit.MILLISECONDS);
} catch (InterruptedExceptione) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Task1 and Task2 have a race condition and unstable execution time: they will impact the performance of each other and anything calling them. While this code looks suspicious, it is representative of real life. People in the OPS/SRE team are not usually aware of all code changes and who did them. They only know something in the new code is causing a problem.&lt;/p&gt;
&lt;p&gt;To make matters interesting, the above code is not always slow: it only happens when the condition is locked. In SkyWalking APM, we have metrics of endpoint p99/p95 latency, so, we are easy to find out the p99 of this endpoint is far from the avg response time. However, this is not the same as understanding the cause of the latency. To locate the root cause, add a profile condition to this endpoint: duration greater than 500ms. This means faster executions will not add profiling load.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;skywalking-blindspot-2.png&#34; alt=&#34;profiled segment&#34;&gt;&lt;/p&gt;
&lt;p&gt;This is a typical profiled trace segment (part of the whole distributed trace) shown on the SkyWalking UI. We now notice the “service/processWithThreadPool” span is slow as we expected, but why? This method is the one we added the faulty code to. As the UI shows that method, we know the profiler is working. Now, let’s see what the profile analysis result say.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;skywalking-blindspot-3.png&#34; alt=&#34;profile analysis&#34;&gt;&lt;/p&gt;
&lt;p&gt;This is the profile analysis stack view. We see the stack element names, duration (include/exclude the children) and slowest methods have been highlighted. It shows clearly, “sun.misc.Unsafe.park” costs the most time. If we look for the caller, it is the code we added: &lt;strong&gt;CountDownLatch.await&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;the-limitations-of-the-profile-method&#34;&gt;The Limitations of the Profile Method&lt;/h3&gt;
&lt;p&gt;No diagnostic tool can fit all cases, not even the profile method.&lt;/p&gt;
&lt;p&gt;The first consideration is mistaking a repeatedly called method for a slow method. Thread dumps are periodic. If there is a loop of calling one method, the profile analysis result would say the target method is slow because it is captured every time in the dump process. There could be another reason. A method called many times can also end up captured in each thread dump. Even so, the profile did what it is designed for. It still helps the OPS/SRE team to locate the code having the issue.&lt;/p&gt;
&lt;p&gt;The second consideration is overhead, the impact of repeated thread dumps is real and can’t be ignored. In SkyWalking, we set the profile dump period to at least 10ms. This means we can’t locate method performance issues if they complete in less than 10ms. SkyWalking has a threshold to control the maximum parallel degree as well.&lt;/p&gt;
&lt;p&gt;Understanding the above keeps distributed tracing and APM systems useful for your OPS/SRE team.&lt;/p&gt;
&lt;h3 id=&#34;how-to-try-this&#34;&gt;How to Try This&lt;/h3&gt;
&lt;p&gt;Everything we discussed, including the Apache SkyWalking Java Agent, profile analysis code, and UI, could be found in our GitHub repository. We hope you enjoyed this new profile method, and love Apache SkyWalking. If so, &lt;a href=&#34;https://github.com/apache/skywalking&#34;&gt;give us a star on GitHub&lt;/a&gt; to encourage us.&lt;/p&gt;
&lt;p&gt;SkyWalking 7 has just been released. You can contact the project team through the following channels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Follow &lt;a href=&#34;https://twitter.com/ASFSkyWalking&#34;&gt;SkyWalking twitter&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Subscribe mailing list: &lt;a href=&#34;mailto:dev@skywalking.apache.org&#34;&gt;dev@skywalking.apache.org&lt;/a&gt;. Send to &lt;a href=&#34;mailto:dev-subscribe@kywalking.apache.org&#34;&gt;dev-subscribe@kywalking.apache.org&lt;/a&gt; to subscribe to the mail list.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Co-author Sheng Wu is a Tetrate founding engineer and the founder and VP of Apache SkyWalking. He is solving the problem of observability for large-scale service meshes in hybrid and multi-cloud environments.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Adrian Cole works in the Spring Cloud team at VMware, mostly on Zipkin&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Han Liu is a tech expert at Lagou. He is an Apache SkyWalking committer&lt;/em&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: SkyWalking hits 200 contributors mark</title>
      <link>https://skywalking.apache.org/blog/2020-01-20-celebrate-200th-contributor/</link>
      <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2020-01-20-celebrate-200th-contributor/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;Author: Wu Sheng, tetrate.io, SkyWalking original creator, SkyWalking V.P.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wu-sheng&#34;&gt;GitHub&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/wusheng1108&#34;&gt;Twitter&lt;/a&gt;, &lt;a href=&#34;https://www.linkedin.com/in/wusheng1108&#34;&gt;Linkedin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;200th-celebration.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The SkyWalking project provides distributed tracing, topology map analysis, service mesh telemetry analysis, metrics analysis and a super cool visualization
targeting distributed systems in k8s or traditional VM deployments.&lt;/p&gt;
&lt;p&gt;The project is widely used in Alibaba, Huawei, Tencent, DiDi, xiaomi, Pingan, China’s top 3 telecom companies (China Mobile, China telecom, China Unicom), airlines, banks and more. It has over 140 company users listed on our &lt;a href=&#34;https://github.com/apache/skywalking/blob/master/docs/powered-by.md&#34;&gt;powered by&lt;/a&gt; page.&lt;/p&gt;
&lt;p&gt;Today, we welcome and celebrate reaching 200 code contributors on our main repo. We hereby mark this milestone as official today, : &lt;strong&gt;Jan. 20th 2020&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;At this great moment, I would like to share SkyWalking’s 4-year open source journey.&lt;/p&gt;
&lt;p&gt;I wrote the first line on Nov. 1st, 2015, guiding people to understand a distributed system just as  micro-services and distributed architecture were becoming popular.
In the first 2 years, I never thought it would become such a big and active community. I didn’t even expect it would be an open source project.
Initially, the goal was primarily to teach others about distributed tracing and analysis.&lt;/p&gt;
&lt;p&gt;It was a typical open source project in obscurity in its first two years. But
people still showed up, asked questions, and tried to improve the project. I got several invitations to share the project at local meetups.All these made me realize people really needed a good open source APM project.&lt;/p&gt;
&lt;p&gt;In 2017, I decided to dedicate myself as much as possible to make the project successful, and it became my day job. To be honest, I had no clue about how to do that; at that time in China, it was rare to have this kind of job.
So, I began to ask friends around me, “Do you want to collaborate on the open source APM with me?” Most people were busy and gave a clear &lt;strong&gt;NO&lt;/strong&gt;, but two of them agreed to help: Xin Zhang and Yongsheng Peng. We built SkyWalking 3.x and shared the 3.2 release at GOPS Shanghai, China.&lt;/p&gt;
&lt;p&gt;It became the first adoption version used in production&lt;/p&gt;
&lt;p&gt;Compared to today&amp;rsquo;s SkyWalking, it was a toy prototype, but it had the same tracing design, protocol and analysis method.&lt;/p&gt;
&lt;p&gt;That year the contributor team was 15-20, and the project had obvious potential to expand. I began to consider bringing the project into a worldwide, top-level open source foundation. Thanks to our initial incubator mentors, Michael Semb Wever, William Jiang, and Luke Han, this really worked.
At the end of 2017, SkyWalking joined the Apache Incubator, and kept following the Apache Way to build community. More contributors joined the community.&lt;/p&gt;
&lt;p&gt;With more people spending time on the project collaborations, including codes, tests, blogs, conference talks, books and uses of the project, a chemical reaction happens. New developers begin to provide bug fixes, new feature requirements and new proposals.
At the moment of graduation in spring 2019, the project had 100 contributors. Now, only 9 months later, it’s surged to 200 super quickly. They enhance the project and extend it to frontiers we never imaged: 5 popular language agents, service mesh adoption, CLI tool, super cool visualization. We are even moving on thread profiling, browser performance and Nginx tracing NOW.&lt;/p&gt;
&lt;p&gt;Over the whole 4+ years open source journey, we have had supports from leaders in the tracing open source community around the world, including Adrian Cole, William Jiang, Luke Han, Michael Semb Wever, Ben Sigelman, and Jonah Kowall. And we’ve had critical  foundations&amp;rsquo; help, especially Apache Software Foundation and the Cloud Native Computing Foundation.&lt;/p&gt;
&lt;p&gt;Our contributors also have their support from their employers, including, to the best of my knowledge, Alibaba, Huawei, China Mobile, ke.com, DaoCloud, Lizhi.fm, Yonghui Supermarket, and dangdang.com. I also have support from my employers, &lt;a href=&#34;https://www.tetrate.io/&#34;&gt;tetrate.io&lt;/a&gt;, Huawei, and OneAPM.&lt;/p&gt;
&lt;p&gt;Thanks to our 200+ contributors and the companies behind them. You make this magic happen.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: SkyWalking alarm webhook sharing</title>
      <link>https://skywalking.apache.org/blog/2019-09-25-alarm-webhook-share/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2019-09-25-alarm-webhook-share/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;Author: Wei Qiang&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/weiqiang333&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;SkyWalking backend provides the alarm function, we can define some Alarm rules, call webhook after the rule is triggered. I share my implementation&lt;/p&gt;
&lt;h2 id=&#34;demonstration&#34;&gt;Demonstration&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;skywalking-UI-alarm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;SkyWalking alarm UI&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;skywalking-dingding-notify.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;dingtalk message body&lt;/p&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;install&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;go get -u github.com/weiqiang333/infra-skywalking-webhook
&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;$GOPATH&lt;/span&gt;/src/github.com/weiqiang333/infra-skywalking-webhook/
bash build/build.sh
./bin/infra-skywalking-webhook &lt;span style=&#34;color:#204a87&#34;&gt;help&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Configuration&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;main configs file&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;configs/production.yml&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;dingtalk&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;p3&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;token...&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Example&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;./bin/infra-skywalking-webhook --config configs/production.yml --address 0.0.0.0:8000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;SkyWalking backend alarm settings&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;webhooks&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;- http&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;//&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;8000&lt;/span&gt;/dingtalk&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;collaboration&#34;&gt;Collaboration&lt;/h2&gt;
&lt;p&gt;Hope that we can improve together &lt;a href=&#34;https://github.com/weiqiang333/infra-skywalking-webhook&#34;&gt;webhook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SkyWalking alarm rules may add more metric names (eg priority name), we can send different channels by locating different levels of alerts (dingtalk / SMS / phone)&lt;/p&gt;
&lt;p&gt;Thanks.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: SkyWalking performance in Service Mesh scenario</title>
      <link>https://skywalking.apache.org/blog/2019-01-25-mesh-loadtest/</link>
      <pubDate>Fri, 25 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2019-01-25-mesh-loadtest/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;Author: Hongtao Gao, Apache SkyWalking &amp;amp; ShardingShpere PMC&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hanahmily&#34;&gt;GitHub&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/hanahmily&#34;&gt;Twitter&lt;/a&gt;, &lt;a href=&#34;https://www.linkedin.com/in/gao-hongtao-47b835168/&#34;&gt;Linkedin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Service mesh receiver was first introduced in Apache SkyWalking 6.0.0-beta. It is designed to provide a common entrance for receiving telemetry data from service mesh framework, for instance, Istio, Linkerd, Envoy etc. What’s the service mesh? According to Istio’s explain:&lt;/p&gt;
&lt;p&gt;The term service mesh is used to describe the network of microservices that make up such applications and the interactions between them.&lt;/p&gt;
&lt;p&gt;As a PMC member of Apache SkyWalking, I tested trace receiver and well understood the performance of collectors in trace scenario. I also would like to figure out the performance of service mesh receiver.&lt;/p&gt;
&lt;h2 id=&#34;different-between-trace-and-service-mesh&#34;&gt;Different between trace and service mesh&lt;/h2&gt;
&lt;p&gt;Following chart presents a typical trace map:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;You could find a variety of elements in it just like web service, local method, database, cache, MQ and so on. But service mesh only collect service network telemetry data that contains the entrance and exit data of a service for now(more elements will be imported soon, just like Database). A smaller quantity of data is sent to the service mesh receiver than the trace.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;But using sidecar is a little different.The client requesting “A” that will send a segment to service mesh receiver from “A”’s sidecar. If “A” depends on “B”,  another segment will be sent from “A”’s sidecar. But for a trace system, only one segment is received by the collector. The sidecar model splits one segment into small segments, that will increase service mesh receiver network overhead.&lt;/p&gt;
&lt;h2 id=&#34;deployment-architecture&#34;&gt;Deployment Architecture&lt;/h2&gt;
&lt;p&gt;In this test, I will pick two different backend deployment. One is called mini unit, consist of one collector and one elasticsearch instance. Another is a standard production cluster, contains three collectors and three elasticsearch instances.&lt;/p&gt;
&lt;p&gt;Mini unit is a suitable architecture for dev or test environment. It saves your time and VM resources, speeds up depolyment process.&lt;/p&gt;
&lt;p&gt;The standard cluster provides good performance and HA for a production scenario. Though you will pay more money and take care of the cluster carefully, the reliability of the cluster will be a good reward to you.&lt;/p&gt;
&lt;p&gt;I pick 8 CPU and 16GB VM to set up the test environment. This test targets the performance of normal usage scenarios, so that choice is reasonable. The cluster is built on Google Kubernetes Engine(GKE), and every node links each other with a VPC network. For running collector is a CPU intensive task, the resource request of collector deployment should be 8 CPU, which means every collector instance occupy a VM node.&lt;/p&gt;
&lt;h2 id=&#34;testing-process&#34;&gt;Testing Process&lt;/h2&gt;
&lt;p&gt;Receiving mesh fragments per second(MPS) depends on the following variables.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ingress query per second(QPS)&lt;/li&gt;
&lt;li&gt;The topology of a microservice cluster&lt;/li&gt;
&lt;li&gt;Service mesh mode(proxy or sidecar)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this test, I use Bookinfo app as a demo cluster.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;So every request will touch max 4 nodes. Plus picking the sidecar mode(every request will send two telemetry data),  the MPS will be QPS * 4 *2.&lt;/p&gt;
&lt;p&gt;There are also some important metrics that should be explained&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client Query Latency: GraphQL API query response time heatmap.&lt;/li&gt;
&lt;li&gt;Client Mesh Sender: Send mesh segments per second. The total line represents total send amount and the error line is the total number of failed send.&lt;/li&gt;
&lt;li&gt;Mesh telemetry latency: service mesh receiver handling data heatmap.&lt;/li&gt;
&lt;li&gt;Mesh telemetry received: received mesh telemetry data per second.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mini-unit&#34;&gt;Mini Unit&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;image3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;You could find collector can process up to &lt;strong&gt;25k&lt;/strong&gt; data per second. The CPU usage is about 4 cores. Most of the query latency is less than 50ms. After login the VM on which collector instance running, I know that system load is reaching the limit(max is 8).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;image2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;According to the previous formula, a single collector instance could process &lt;strong&gt;3k&lt;/strong&gt; QPS of Bookinfo traffic.&lt;/p&gt;
&lt;h3 id=&#34;standard-cluster&#34;&gt;Standard Cluster&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;image4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Compare to the mini-unit, cluster’s throughput increases linearly. Three instances provide total 80k per second processing power. Query latency increases slightly, but it’s also very small(less than 500ms). I also checked every collector instance system load that all reached the limit. 10k QPS of BookInfo telemetry data could be processed by the cluster.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Let’s wrap them up. There are some important things you could get from this test.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QPS varies by the there variables. The test results in this blog are not important. The user should pick property value according to his system.&lt;/li&gt;
&lt;li&gt;Collector cluster’s processing power could scale out.&lt;/li&gt;
&lt;li&gt;The collector is CPU intensive application. So you should provide sufficient CPU resource to it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This blog gives people a common method to evaluate the throughput of Service Mesh Receiver. Users could use this to design their Apache Skywalking backend deployment architecture.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Understand distributed trace easier in the incoming 6-GA</title>
      <link>https://skywalking.apache.org/blog/2019-01-01-understand-trace/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2019-01-01-understand-trace/</guid>
      <description>
        
        
        &lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;p&gt;Distributed tracing is a necessary part of modern microservices architecture, but how to understand or use distributed tracing data is unclear to some end users. This blog overviews typical distributed tracing use cases with new visualization features in SkyWalking v6. We hope new users will understand more through these examples.&lt;/p&gt;
&lt;h2 id=&#34;metric-and-topology&#34;&gt;Metric and topology&lt;/h2&gt;
&lt;p&gt;Trace data underpins in two well known analysis features: &lt;strong&gt;metric&lt;/strong&gt; and &lt;strong&gt;topology&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Metric&lt;/strong&gt; of each service, service instance, endpoint are derived from entry spans in trace. Metrics represent response time performance. So, you could have average response time, 99% response time, success rate, etc. These are broken down by service, service instance, endpoint.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Topology&lt;/strong&gt; represents links between services and is distributed tracing&amp;rsquo;s most attractive feature. Topologies allows all users to understand distributed service relationships and dependencies even when they are varied or complex. This is important as it brings a single view to all interested parties, regardless of if they are a developer, designer or operator.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s an example topology of 4 projects, including Kafka and two outside dependencies.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./demo-spring.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;Topology in SkyWalking optional UI, RocketBot&lt;/p&gt;
&lt;h2 id=&#34;trace&#34;&gt;Trace&lt;/h2&gt;
&lt;p&gt;In a distributed tracing system, we spend a lot of resources(CPU, Memory, Disk and Network) to generate, transport and persistent trace data. Let&amp;rsquo;s try to answer why we do this? What are the typical diagnosis and system performance questions we can answer with trace data?&lt;/p&gt;
&lt;p&gt;SkyWalking v6 includes two trace views:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TreeMode: The first time provided. Help you easier to identify issues.&lt;/li&gt;
&lt;li&gt;ListMode: Traditional view in time line, also usually seen in other tracing system, such as Zipkin.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;error-occurred&#34;&gt;Error occurred&lt;/h3&gt;
&lt;p&gt;In the trace view, the easiest part is locating the error, possibly caused by a code exception or network fault. Both ListMode and TreeMode can identify errors, while the span detail screen provides details.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;span-error.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;ListMode error span&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;span-error-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;TreeMode error span&lt;/p&gt;
&lt;h3 id=&#34;slow-span&#34;&gt;Slow span&lt;/h3&gt;
&lt;p&gt;A high priority feature is identifying the slowest spans in a trace. This uses execution duration captured by application agents. In the old ListMode trace view, parent span almost always includes the child span&amp;rsquo;s duration, due to nesting. In other words, a slow span usually causes its parent to also become slow. In SkyWalking 6, we provide &lt;code&gt;Top 5 of slow span&lt;/code&gt; filter to help you locate the spans directly.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;top5-span.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;Top 5 slow span&lt;/p&gt;
&lt;p&gt;The above screenshot highlights the top 5 slow spans, excluding child span duration. Also, this shows all spans&amp;rsquo; execution time, which helps identify the slowest ones.&lt;/p&gt;
&lt;h3 id=&#34;too-many-child-spans&#34;&gt;Too many child spans&lt;/h3&gt;
&lt;p&gt;In some cases, individual durations are quick, but the trace is still slow, like this one:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;top5-not-clear.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;Trace with no slow span&lt;/p&gt;
&lt;p&gt;To understand if the root problem is related to too many operations, use &lt;code&gt;Top 5 of children span number&lt;/code&gt;. This filter shows the amount of children each span has, highlighting the top 5.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;too-many-child.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;13 database accesses of a span&lt;/p&gt;
&lt;p&gt;In this screenshot, there is a span with 13 children, which are all Database accesses. Also, when you see overview of trace, database cost 1380ms of this 2000ms trace.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;database-long-duration.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;1380ms database accesses&lt;/p&gt;
&lt;p&gt;In this example, the root cause is too many database accesses. This is also typical in other scenarios like too many RPCs or cache accesses.&lt;/p&gt;
&lt;h3 id=&#34;trace-depth&#34;&gt;Trace depth&lt;/h3&gt;
&lt;p&gt;Trace depth is also related latency. Like the &lt;a href=&#34;#too-many-child-spans&#34;&gt;too many child spans&lt;/a&gt; scenario, each span latency looks good, but the whole trace is slow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;deep-trace-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;Trace depth&lt;/p&gt;
&lt;p&gt;Here, the slowest spans are less than 500ms, which are not too slow for a 2000ms trace. When you see the first line, there are four different colors representing four services involved in this distributed trace. Every one of them costs 100~400ms. For all four, there nearly 2000ms. From here, we know this slow trace is caused by 3 RPCs in a serial sequence.&lt;/p&gt;
&lt;h2 id=&#34;at-the-end&#34;&gt;At the end&lt;/h2&gt;
&lt;p&gt;Distributed tracing and APM tools help users identify root causes, allowing development and operation teams to optimize accordingly. We hope you enjoyed this, and love Apache SkyWalking and our new trace visualization. If so, &lt;a href=&#34;https://github.com/apache/incubator-skywalking&#34;&gt;give us a star on GitHub&lt;/a&gt; to encourage us.&lt;/p&gt;
&lt;p&gt;SkyWalking 6 is scheduled to release at the end of January 2019. You can contact the project team through the following channels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Follow &lt;a href=&#34;https://twitter.com/ASFSkyWalking&#34;&gt;SkyWalking twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Subscribe mailing list: &lt;a href=&#34;mailto:dev@skywalking.apache.org&#34;&gt;dev@skywalking.apache.org&lt;/a&gt; . Send to &lt;a href=&#34;mailto:dev-subscribe@kywalking.apache.org&#34;&gt;dev-subscribe@kywalking.apache.org&lt;/a&gt; to subscribe the mail list.&lt;/li&gt;
&lt;li&gt;Join &lt;a href=&#34;https://gitter.im/OpenSkywalking/Lobby&#34;&gt;Gitter&lt;/a&gt; room.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: SkyWalking v6 is Service Mesh ready</title>
      <link>https://skywalking.apache.org/blog/2018-12-12-skywalking-service-mesh-ready/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2018-12-12-skywalking-service-mesh-ready/</guid>
      <description>
        
        
        &lt;p&gt;Original link, &lt;a href=&#34;https://www.tetrate.io/blog/apache-skywalking-v6/&#34;&gt;Tetrate.io blog&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;context&#34;&gt;Context&lt;/h1&gt;
&lt;p&gt;The integration of SkyWalking and Istio Service Mesh yields an essential open-source tool for resolving the chaos created by the proliferation of siloed, cloud-based services.&lt;/p&gt;
&lt;p&gt;Apache SkyWalking is an open, modern performance management tool for distributed services, designed especially for microservices, cloud native and container-based (Docker, K8s, Mesos) architectures. We at Tetrate believe it is going to be an important project for understanding the performance of microservices. The recently released v6 integrates with Istio Service Mesh and focuses on metrics and tracing. It natively understands the most common language runtimes (Java, .Net, and NodeJS). With its new core code, SkyWalking v6 also supports Istrio telemetry data formats, providing consistent analysis, persistence, and visualization.&lt;/p&gt;
&lt;p&gt;SkyWalking has evolved into an Observability Analysis Platform that enables observation and monitoring of hundreds of services all at once. It promises solutions for some of the trickiest problems faced by system administrators using complex arrays of abundant services: Identifying why and where a request is slow, distinguishing normal from deviant system performance, comparing apples-to-apples metrics across apps regardless of programming language, and attaining a complete and meaningful view of performance.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gl2ctge1g5j31pc0s8h04.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;skywalking-history&#34;&gt;SkyWalking History&lt;/h1&gt;
&lt;p&gt;Launched in China by Wu Sheng in 2015, SkyWalking started as just a distributed tracing system, like Zipkin, but with auto instrumentation from a Java agent. This enabled JVM users to see distributed traces without any change to their source code. In the last two years, it has been used for research and production by more than &lt;a href=&#34;https://github.com/apache/incubator-skywalking/blob/master/docs/powered-by.md&#34;&gt;50 companies&lt;/a&gt;. With its expanded capabilities, we expect to see it adopted more globally.&lt;/p&gt;
&lt;h1 id=&#34;whats-new&#34;&gt;What&amp;rsquo;s new&lt;/h1&gt;
&lt;h2 id=&#34;service-mesh-integration&#34;&gt;Service Mesh Integration&lt;/h2&gt;
&lt;p&gt;Istio has picked up a lot of steam as the framework of choice for distributed services. Based on all the interest in the Istio project, and community feedback, some SkyWalking (P)PMC members decided to integrate with Istio Service Mesh to move SkyWalking to a higher level.&lt;/p&gt;
&lt;p&gt;So now you can use Skywalking to get metrics and understand the topology of your applications. This works not just for Java, .NET and Node using our language agents, but also for microservices running under the Istio service mesh. You can get a full topology of both kinds of applications.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gl2cjmhi3uj31h80m5jwn.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;observability-analysis-platform&#34;&gt;Observability analysis platform&lt;/h2&gt;
&lt;p&gt;With its roots in tracing, SkyWalking is now transitioning into an open-standards based &lt;strong&gt;Observability Analysis Platform&lt;/strong&gt;, which means the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It can accept different kinds and formats of telemetry data from mesh like Istio telemetry.&lt;/li&gt;
&lt;li&gt;Its agents support various popular software technologies and frameworks like Tomcat, Spring, Kafka. The whole supported framework list is &lt;a href=&#34;https://github.com/apache/incubator-skywalking/blob/master/docs/en/setup/service-agent/java-agent/Supported-list.md&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;It can accept data from other compliant sources like Zipkin-formatted traces reported from Zipkin, Jaeger, or OpenCensus clients.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gl2cqo4yctj31ok0s07hh.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;SkyWalking is logically split into four parts: Probes, Platform Backend, Storage and UI:&lt;/p&gt;
&lt;p&gt;There are two kinds of &lt;strong&gt;probes&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Language agents or SDKs following SkyWalking across-thread propagation formats and trace formats, run in the user’s application process.&lt;/li&gt;
&lt;li&gt;The Istio mixer adaptor, which collects telemetry from the Service Mesh.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The platform &lt;strong&gt;backend&lt;/strong&gt; provides gRPC and RESTful HTTP endpoints for all SkyWalking-supported trace and metric telemetry data. For example, you can stream these metrics into an analysis system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Storage&lt;/strong&gt; supports multiple implementations such as ElasticSearch, H2 (alpha), MySQL, and Apache ShardingSphere for MySQL Cluster. TiDB will be supported in next release.&lt;/p&gt;
&lt;p&gt;SkyWalking’s built-in &lt;strong&gt;UI&lt;/strong&gt; with a GraphQL endpoint for data allows intuitive, customizable integration.&lt;/p&gt;
&lt;p&gt;Some examples of SkyWalking’s UI:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Observe a Spring app using the SkyWalking JVM-agent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gl2ckeyyxlj31h70lvdjf.jpg&#34; alt=&#34;Topology&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Observe on Istio without any agent, no matter what langugage the service is written in&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gl2ckwr65mj31h80m5jwn.jpg&#34; alt=&#34;Topology&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;See fine-grained metrics like request/Call per Minute, P99/95/90/75/50 latency, avg response time, heatmap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gl2cmxcrdqj31gz0qmdja.jpg&#34; alt=&#34;Dashboard&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service dependencies and metrics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gl2cngbu84j31h00oxadw.jpg&#34; alt=&#34;Service&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;service-focused&#34;&gt;Service Focused&lt;/h1&gt;
&lt;p&gt;At Tetrate, we are focused on discovery, reliability, and security of your running services.
This is why we are embracing Skywalking, which makes service performance observable.&lt;/p&gt;
&lt;p&gt;Behind this admittedly cool UI, the aggregation logic is very easy to understand, making it easy to customize SkyWalking in its Observability Analysis Language (OAL) script.&lt;/p&gt;
&lt;p&gt;We’ll post more about OAL for developers looking to customize SkyWalking, and you can read the official &lt;a href=&#34;https://github.com/apache/incubator-skywalking/blob/master/docs/en/concepts-and-designs/oal.md&#34;&gt;OAL introduction&lt;/a&gt; document.&lt;/p&gt;
&lt;p&gt;Scripts are based on three core concepts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Service&lt;/strong&gt; represents a group of workloads that provide the same behaviours for incoming requests. You can define the service name whether you are using instrument agents or SDKs. Otherwise, SkyWalking uses the name you defined in the underlying platform, such as Istio.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Service Instance&lt;/strong&gt; Each workload in the Service group is called an instance. Like &lt;em&gt;Pods&lt;/em&gt; in Kubernetes, it doesn&amp;rsquo;t need  to be a single OS process. If you are using an instrument agent, an instance does map to one OS process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Endpoint&lt;/strong&gt; is a path in a certain service that handles incoming requests, such as HTTP paths or a gRPC service + method. Mesh telemetry and trace data are formatted as source objects (aka scope). These are the input for the aggregation, with the script describing how to aggregate, including input, conditions, and the resulting metric name.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;core-features&#34;&gt;Core Features&lt;/h1&gt;
&lt;p&gt;The other core features in SkyWalking v6 are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service, service instance, endpoint metrics analysis.&lt;/li&gt;
&lt;li&gt;Consistent visualization in Service Mesh and no mesh.&lt;/li&gt;
&lt;li&gt;Topology discovery, Service dependency analysis.&lt;/li&gt;
&lt;li&gt;Distributed tracing.&lt;/li&gt;
&lt;li&gt;Slow services and endpoints detected.&lt;/li&gt;
&lt;li&gt;Alarms.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course, SkyWalking has some more upgrades from v5, such as:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ElasticSearch 6 as storage is supported.&lt;/li&gt;
&lt;li&gt;H2 storage implementor is back.&lt;/li&gt;
&lt;li&gt;Kubernetes cluster management is provided. You don’t need Zookeeper to keep the backend running in cluster mode.&lt;/li&gt;
&lt;li&gt;Totally new alarm core. Easier configuration.&lt;/li&gt;
&lt;li&gt;More cloud native style.&lt;/li&gt;
&lt;li&gt;MySQL will be supported in the next release.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;please-test-and-provide-feedback&#34;&gt;Please: Test and Provide Feedback!&lt;/h1&gt;
&lt;p&gt;We would love everyone to try to test our new version. You can find everything you need in our &lt;a href=&#34;https://github.com/apache/incubator-skywalking&#34;&gt;Apache repository&lt;/a&gt;,read the &lt;a href=&#34;https://github.com/apache/incubator-skywalking/blob/master/docs/README.md&#34;&gt;document&lt;/a&gt; for further details. You can contact the project team through the following channels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Submit an issue on &lt;a href=&#34;https://github.com/apache/incubator-skywalking/issues/new&#34;&gt;GitHub repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mailing list: &lt;a href=&#34;mailto:dev@skywalking.apache.org&#34;&gt;dev@skywalking.apache.org&lt;/a&gt; . Send to &lt;a href=&#34;mailto:dev-subscribe@kywalking.apache.org&#34;&gt;dev-subscribe@kywalking.apache.org&lt;/a&gt; to subscribe the mail list.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gitter.im/OpenSkywalking/Lobby&#34;&gt;Gitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/ASFSkyWalking&#34;&gt;Project twitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Oh, and one last thing! If you like our project, don&amp;rsquo;t forget to &lt;a href=&#34;https://github.com/apache/incubator-skywalking&#34;&gt;give us a star on GitHub&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Apache SkyWalking provides open source APM and distributed tracing in .NET Core field</title>
      <link>https://skywalking.apache.org/blog/2018-05-24-skywalking-net/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://skywalking.apache.org/blog/2018-05-24-skywalking-net/</guid>
      <description>
        
        
        &lt;p&gt;Translated by Sheng Wu.&lt;/p&gt;
&lt;p&gt;In many big systems, distributed and especially microservice architectures become more and more popular. With the increase of modules and services, one incoming request could cross dozens of service. How to pinpoint the issues of the online system, and the bottleneck of the whole distributed system? This became a very important problem, which must be resolved.&lt;/p&gt;
&lt;p&gt;To resolve the problems in distributed system, Google published the paper “Dapper, a Large-Scale Distributed Systems Tracing Infrastructure”, which mentioned the designs and ideas of building a distributed system. Many projects are inspired by it, created in the last 10 years. At 2015, Apache SkyWalking was created by Wu Sheng as a simple distributed system at first and open source. Through almost 3 years developments, at 2018, according to its 5.0.0-alpha/beta releases, it had already became a cool open source APM system for cloud native, container based system.&lt;/p&gt;
&lt;p&gt;At the early of this year, I was trying to build the Butterfly open source APM in .NET Core, and that is when I met the Apache SkyWalking team and its creator. I decided to join them, and cooperate with them, to provide .NET Core agent native compatible with SkyWalking. At April, I released the first version .NET core agent 0.1.0. After several weeks interation, we released 0.2.0, for increasing the stability and adding HttpClient, Database driver supports.&lt;/p&gt;
&lt;p&gt;Before we used .NET Core agent, we need to deploy SkyWalking collector, UI and ElasticSearch 5.x. You can download the release versions at here: &lt;a href=&#34;http://skywalking.apache.org/downloads/&#34;&gt;http://skywalking.apache.org/downloads/&lt;/a&gt; and follow the docs (Deploy-backend-in-standalone-mode, Deploy-backend-in-cluster-mode) to setup the backend.&lt;/p&gt;
&lt;p&gt;At here, I are giving a quick start to represent, how to monitor a demo distributed .NET Core applications. I can say, that is easy.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git clone &lt;a href=&#34;https://github.com/OpenSkywalking/skywalking-netcore.git&#34;&gt;https://github.com/OpenSkywalking/skywalking-netcore.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;cd skywalking-netcore&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;dotnet restore&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;dotnet run -p sample/SkyWalking.Sample.Backend
dotnet run -p sample/SkyWalking.Sample.Frontend&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now you can open http://localhost:5001/api/values to access the demo application. Then you can open SkyWalking WebUI http://localhost:8080&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Overview of the whole distributed system
&lt;img src=&#34;https://cdn-images-1.medium.com/max/1600/1*sZY-9RaSz40sAHLkhwSV5g.png&#34;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Topology of distributed system
&lt;img src=&#34;https://cdn-images-1.medium.com/max/1600/1*mMEGHg12fziDdeoa4r9CrA.png&#34;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application view
&lt;img src=&#34;https://cdn-images-1.medium.com/max/1600/1*uxBlfP6Byvf8xpRpG-qRZw.png&#34;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trace query
&lt;img src=&#34;https://cdn-images-1.medium.com/max/1600/1*bj8bdC7LscCD4tmcs8c_gg.png&#34;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Span’s tags, logs and related traces
&lt;img src=&#34;https://cdn-images-1.medium.com/max/1600/1*bj8bdC7LscCD4tmcs8c_gg.png&#34;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;github&#34;&gt;GitHub&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Website: &lt;a href=&#34;http://skywalking.apache.org/&#34;&gt;http://skywalking.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SkyWalking Github Repo: &lt;a href=&#34;https://github.com/apache/incubator-skywalking&#34;&gt;https://github.com/apache/incubator-skywalking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SkyWalking-NetCore Github Repo: &lt;a href=&#34;https://github.com/OpenSkywalking/skywalking-netcore&#34;&gt;https://github.com/OpenSkywalking/skywalking-netcore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
