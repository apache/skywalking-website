<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apache SkyWalking – Use Case</title>
    <link>/zh_tags/use-case/</link>
    <description>Recent content in Use Case on Apache SkyWalking</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 11 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/zh_tags/use-case/feed.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Zh: SkyWalking 为超大规模而生</title>
      <link>/zh/2020-08-11-observability-at-scale-skywalking-it-is/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/zh/2020-08-11-observability-at-scale-skywalking-it-is/</guid>
      <description>
        
        
        &lt;ul&gt;
&lt;li&gt;作者：吴晟&lt;/li&gt;
&lt;li&gt;翻译：董旭 金蝶医疗&lt;/li&gt;
&lt;li&gt;原文链接：&lt;a href=&#34;https://www.tetrate.io/blog/observability-at-scale-skywalking-it-is/&#34;&gt;Tetrate.io blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SkyWalking做为Apache的顶级项目，是一个开源的APM和可观测性分析平台，它解决了21世纪日益庞大、分布式和异构的系统的问题。它是为应对当前系统管理所面临的困难而构建的：就像大海捞针，SkyWalking可以在服务依赖复杂且多语言环境下，获取服务对应的指标，以及完整而有意义的性能视图。&lt;/p&gt;
&lt;p&gt;SkyWalking是一个非常全面的平台，无论你的微服务是否在服务网格(Service Mesh)架构下，它都可以提供高性能且一致性的监控。&lt;/p&gt;
&lt;p&gt;让我们来看看，SkyWalking是如何解决大规模集群的可观测性问题，并从一个纯粹的链路跟踪系统，发展成为一个每天分析百亿级跟踪数据，功能丰富的可观测性平台。&lt;/p&gt;
&lt;h3 id=&#34;为超大规模而生&#34;&gt;为超大规模而生&lt;/h3&gt;
&lt;p&gt;SkyWalking的诞生，时间要追溯到2015年，当时它主要应用于监控顶级电信公司（例如：中国联通和中国移动）的第一代分布式核心系统。2013-2014年，这些电信公司计划用分布式系统取代传统的单体架构应用。从诞生那天开始，SkyWalking首要的设计目标，就是能够支持超大型分布式系统，并具有很好可扩展性。那么支撑超大规模系统要考虑什么呢？&lt;/p&gt;
&lt;h3 id=&#34;拉取vs推送&#34;&gt;拉取vs推送&lt;/h3&gt;
&lt;p&gt;与数据流向息息相关的：拉取模式和推送模式。Agent（客户端）收集数据并将其推送到后端，再对数据进一步分析，我们称之为“推送”模式。究竟应该使用拉取还是推送？这个话题已经争论已久。关键因素取决于可观测性系统的目标，即：在Agent端花最小的成本，使其适配不同类型的可观测性数据。&lt;/p&gt;
&lt;p&gt;Agent收集数据后，可以在短时间内发送出去。这样，我们就不必担心本地缓存压力过大。举一个典型的例子，任意服务都可以轻松地拥有数百个甚至数千个端点指标（如：HTTP的URI，gRPC的服务）。那么APM系统就必须具有分析这些数量庞大指标的能力。&lt;/p&gt;
&lt;p&gt;此外，度量指标并不是可观测性领域中的唯一关注点，链路跟踪和日志也很重要。在生产环境下，SkyWalking为了能提供100%采样率的跟踪能力，数据推送模式是唯一可行的解决方案。&lt;/p&gt;
&lt;p&gt;SkyWalking即便使用了推送模式，同时也可进行数据拉取。在最近的8.x的发版本中，SkyWalking支持从已经集成Prometheus的服务中获取终端用户的数据，避免重复工程建设，减少资源浪费。另外，比较常见的是基于MQ的传输构建拉取模式，Kafka消费者就是一个比较典型的例子。SkyWalking的Agent端使用推送模式，OAP服务器端使用拉取模式。&lt;/p&gt;
&lt;p&gt;结论：SkyWalking的推送模式是原生方式，但拉取式模式也适用于某些特殊场景。&lt;/p&gt;
&lt;h3 id=&#34;度量指标分析并不仅仅是数学统计&#34;&gt;度量指标分析并不仅仅是数学统计&lt;/h3&gt;
&lt;p&gt;度量指标依赖于数学理论和计算。Percentile（百分位数）是用于反映响应时间的长尾效应。服务具备合理的平均响应时间和成功率，说明服务的服务等级目标(SLO）很好。除此之外，分布式跟踪还为跟踪提供了详细的信息，以及可分析的高价值指标。&lt;/p&gt;
&lt;p&gt;运维团队（OPS）和系统稳定性（SRE）团队通过服务拓扑图，用来观察网络情况（当做NOC dashboard使用）、确认系统数据流。SkyWalking依靠trace（跟踪数据），使用&lt;a href=&#34;https://wu-sheng.github.io/STAM/&#34;&gt;STAM（Streaming Topology Analysis Method）&lt;/a&gt;方法进行分析拓扑结构。在服务网格环境下，使用ALS（Envoy Access Log Service）进行拓扑分析。节点（services）和线路（service relationships）的拓扑结构和度量指标数据，无法通过sdk轻而易举的拿到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl5dayj8mj31uy0u0184.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了解决端点度量指标收集的局限性，SkyWalking还要从跟踪数据中分析端点依赖关系，从而拿到链路上游、下游这些关键具体的信息。这些依赖关系和度量指标信息，有助于开发团队定位引起性能问题的边界，甚至代码块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl5dcuk7rj31v40u0gw4.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;预计算还是查询时计算&#34;&gt;预计算还是查询时计算？&lt;/h3&gt;
&lt;p&gt;相比查询时计算的灵活性，预计算可以提供更好、更稳定的性能，这在分析场景下尤为重要。回想一下我们的设计原则：SkyWalking是为了一个大规模的分布式系统而设计。查询时计算的使用范围非常有限，大多数度量计算都需要预先定义和预先计算。支持大数据集的关键是：在设计阶段，要减小数据集。预计算允许将原始数据合并到下游的聚合结果中，用于查询，甚至用于警报检查。&lt;/p&gt;
&lt;p&gt;使用SkyWalking的另一个重要因素是：指标的有效期，TTL（Time To Live）。由于采用了预先计算，查询提供了近似线性的高性能。这也帮助“查询系统”这类基础设施系统，提供更好的性能扩展。&lt;/p&gt;
&lt;p&gt;关于警报，使用查询时计算方案，也意味着警报查询需要基于查询引擎。但在这种情况下，随着数据集增加，查询性能会随之下降，其他指标查询也是一样的结果。&lt;/p&gt;
&lt;h3 id=&#34;目前使用案例&#34;&gt;目前使用案例&lt;/h3&gt;
&lt;p&gt;如今，SkyWalking在许多大型企业的超大规模分布式系统中使用，包括阿里巴巴、华为、腾讯、百度、中国通讯企业以及多家银行和保险公司。上线SkyWalking公司的流量，比银行和电信运营商这种传统公司还要大。&lt;/p&gt;
&lt;p&gt;在很多行业中，SkyWalking是被应用于超大型分布式系统各种场景下的一个可观测性平台：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拉勾网&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SkyWalking正在观测超过100个服务，500多个JVM实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SkyWalking每天收集和分析40多亿个跟踪数据，用来分析性能，其中包括30万个端点和依赖关系的指标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在整个群集中监控&amp;gt;50k流量/秒&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永辉超市&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SkyWalking每天分析至少100多亿（3B）的跟踪数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，SkyWalking用较小的部署，每天分析2亿多个跟踪数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;百度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SkyWalking每天从1400多个pod中，从120多个服务收集1T以上的跟踪数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随着更多服务的增加，规模会持续增大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;贝壳找房(ke.com)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;很早就使用了SkyWalking，有两名成员已经成为PMC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deployments每天收集160多亿个跟踪数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阿里云效&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SkyWalking每天收集和分析数十亿个span&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SkyWalking使阿里云的45项服务和~300个实例保持稳定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阿里巴巴天猫&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SkyWalking个性化定制版，每天监控数十亿跟踪数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与此同时，他们基于SkyWalking的Agent技术栈，利用其跟踪和上下文传播能力，正在构建一个全链路压测平台&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;
&lt;p&gt;SkyWalking针对可观测性遵循以下原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;理解逻辑模型：不要把可观测性当作数学统计工具。&lt;/li&gt;
&lt;li&gt;首先确定依赖关系，然后确定它们的度量指标。&lt;/li&gt;
&lt;li&gt;原生和方便的支撑大规模增长。&lt;/li&gt;
&lt;li&gt;在不同的架构情况下，APM各方面表现依然保持稳定和一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;资源&#34;&gt;资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;阅读&lt;a href=&#34;https://github.com/apache/skywalking/blob/master/CHANGES.md&#34;&gt;SkyWalking 8.1发布亮点&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;在&lt;a href=&#34;https://twitter.com/asfskywalking?lang=en&#34;&gt;Twitter&lt;/a&gt;上获取更多SkyWalking更新。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tetrate.io/contact-us/&#34;&gt;注册Tetrate&lt;/a&gt;以了解更多有关SkyWalking可观测性的信息。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Zh: SkyWalking调研与初步实践</title>
      <link>/zh/2019-03-29-introduction-of-skywalking-and-simple-practice/</link>
      <pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/zh/2019-03-29-introduction-of-skywalking-and-simple-practice/</guid>
      <description>
        
        
        &lt;h2 id=&#34;apm和调用链跟踪&#34;&gt;APM和调用链跟踪&lt;/h2&gt;
&lt;p&gt;随着企业经营规模的扩大，以及对内快速诊断效率和对外SLA（服务品质协议，service-level agreement)的追求，对于业务系统的掌控度的要求越来越高，主要体现在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于第三方依赖的监控，实时/准实时了解第三方的健康状况/服务品质，降低第三方依赖对于自身系统的扰动（服务降级、故障转移）&lt;/li&gt;
&lt;li&gt;对于容器的监控，实时/准实时的了解应用部署环境（CPU、内存、进程、线程、网络、带宽）情况，以便快速扩容/缩容、流量控制、业务迁移&lt;/li&gt;
&lt;li&gt;业务方对于自己的调用情况，方便作容量规划，同时对于突发的请求也能进行异常告警和应急准备&lt;/li&gt;
&lt;li&gt;自己业务的健康、性能监控，实时/准实时的了解自身的业务运行情况，排查业务瓶颈，快速诊断和定位异常，增加对自己业务的掌控力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时，对于企业来说，能够更精确的了解资源的使用情况，对于成本核算和控制也有非常大的裨益。&lt;/p&gt;
&lt;p&gt;在这种情况下，一般都会引入APM（Application Performance Management &amp;amp; Monitoring）系统，通过各种探针采集数据，收集关键指标，同时搭配数据呈现和监控告警，能够解决上述的大部分问题。&lt;/p&gt;
&lt;p&gt;然而随着RPC框架、微服务、云计算、大数据的发展，同时业务的规模和深度相比过往也都增加了很多，一次业务可能横跨多个模块/服务/容器，依赖的中间件也越来越多，其中任何一个节点出现异常，都可能导致业务出现波动或者异常，这就导致服务质量监控和异常诊断/定位变得异常复杂，于是催生了新的业务监控模式：调用链跟踪&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够分布式的抓取多个节点的业务记录，并且通过统一的业务id（traceId，messageId，requestId等）将一次业务在各个节点的记录串联起来，方便排查业务的瓶颈或者异常点&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;产品对比&#34;&gt;产品对比&lt;/h4&gt;
&lt;p&gt;APM和调用链跟踪均不是新诞生事务，很多公司已经有了大量的实践，不过开源的并且能够开箱即用的产品并不多，这里主要选取了Pinpoint，Skywalking，CAT来进行对比（当然也有其他的例如Zipkin，Jaeger等产品，不过总体来说不如前面选取的3个完成度高），了解一下APM和调用链跟踪在开源方面的发展状态。&lt;/p&gt;
&lt;h6 id=&#34;pinpoint&#34;&gt;Pinpoint&lt;/h6&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/naver/pinpoint&#34;&gt;Pinpoint&lt;/a&gt;是一个比较早并且成熟度也非常高的APM+调用链监控的项目，在全世界范围内均有用户使用，支持Java和PHP的探针，数据容器为HBase，其界面参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q40u9jj316z0q7gpl.jpg&#34; alt=&#34;pinpoint_server-map&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;skywalking&#34;&gt;Skywalking&lt;/h6&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apache/incubator-skywalking&#34;&gt;Skywalking&lt;/a&gt;是一个新晋的项目，最近一两年发展非常迅猛，本身支持OpenTracing规范，优秀的设计提供了良好的扩展性，支持Java、PHP、.Net、NodeJs探针，数据容器为ElasticSearch，其界面参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4qcx4bzj31h10qjtcv.jpg&#34; alt=&#34;skywalking-dashboard&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;cat&#34;&gt;CAT&lt;/h6&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dianping/cat&#34;&gt;CAT&lt;/a&gt;是由美团开源的一个APM项目，也历经了多年的迭代升级，拥有大量的企业级用户，对于监控和报警整合比较紧密，支持Java、C/C++、.Net、Python、Go、NodeJs，不过CAT目前主要通过侵入性的方式接入，数据容器包括HDFS（存储原始数据）和mysql（二次统计），其界面参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q862ehj31go0os0vv.jpg&#34; alt=&#34;CAT&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;横向对比&#34;&gt;横向对比&lt;/h6&gt;
&lt;p&gt;上面只是做了一个简介，那这三个项目各自有什么特色或者优势/劣势呢（三者的主要产品均针对Java，这里也主要针对Java的特性）？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pinpoint
&lt;ul&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;大企业/长时间验证，稳定性和完成度高&lt;/li&gt;
&lt;li&gt;探针收集的数据粒度比较细&lt;/li&gt;
&lt;li&gt;HBase的数据密度较大，支持PB级别下的数据查询&lt;/li&gt;
&lt;li&gt;代码设计考虑的扩展性较弱，二次开发难度较大（探针为插件式，开发比较简单）&lt;/li&gt;
&lt;li&gt;拥有完整的APM和调用链跟踪功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劣势
&lt;ul&gt;
&lt;li&gt;代码针对性强，扩展较难&lt;/li&gt;
&lt;li&gt;容器为HBase，查询功能较弱（主要为时间维度）&lt;/li&gt;
&lt;li&gt;探针的额外消耗较多（探针采集粒度细，大概10%~20%）&lt;/li&gt;
&lt;li&gt;项目趋于成熟，而扩展难度较大，目前社区活跃度偏低，基本只进行探针的增加或者升级&lt;/li&gt;
&lt;li&gt;缺少自定义指标的设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Skywalking
&lt;ul&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;数据容器为ES，查询支持的维度较多并且扩展潜力大&lt;/li&gt;
&lt;li&gt;项目设计采用微内核+插件，易读性和扩展性都比较强&lt;/li&gt;
&lt;li&gt;主要的研发人员为华人并且均比较活跃，能够进行更加直接的沟通&lt;/li&gt;
&lt;li&gt;拥有完整的APM和调用链跟踪功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劣势
&lt;ul&gt;
&lt;li&gt;项目发展非常快，稳定性有待验证&lt;/li&gt;
&lt;li&gt;ES数据密度较小，在PB级别可能会有性能压力&lt;/li&gt;
&lt;li&gt;缺少自定义指标的设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CAT
&lt;ul&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;大企业/长时间验证，稳定性和完成度高&lt;/li&gt;
&lt;li&gt;采用手动数据埋点而不是探针，数据采集的灵活性更强&lt;/li&gt;
&lt;li&gt;支持自定义指标&lt;/li&gt;
&lt;li&gt;代码设计考虑的扩展性较弱，并且数据结构复杂，二次开发难度较大&lt;/li&gt;
&lt;li&gt;拥有完善的监控告警机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劣势
&lt;ul&gt;
&lt;li&gt;代码针对性强，扩展较难&lt;/li&gt;
&lt;li&gt;需要手动接入埋点，代码侵入性强&lt;/li&gt;
&lt;li&gt;APM功能完善，但是不支持调用链跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基本组件&#34;&gt;基本组件&lt;/h4&gt;
&lt;p&gt;如果分别去看Pinpoint/Skywalking/CAT的整体设计，我们会发现三者更像是一个规范的三种实现，虽然各自有不同的机制和特性，但是从模块划分和功能基本是一致的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4qa2gf2j30no0gvwfd.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然也有一些微小的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pinpoint基本没有aggregator，同时query和alarm集成在了web中，只有agent，collector和web&lt;/li&gt;
&lt;li&gt;Skywalking则是把collector、aggregator、alarm集成为OAP（Observability Analysis Platform），并且可以通过集群部署，不同的实例可以分别承担collector或者aggregator+alarm的角色&lt;/li&gt;
&lt;li&gt;CAT则和Skywalking类似，把collector、aggregator、alarm集成为cat-consumer，而由于CAT有比较复杂的配置管理，所以query和配置一起集成为cat-home&lt;/li&gt;
&lt;li&gt;当然最大的区别是Pinpoint和Skywalking均是通过javaagent做字节码的扩展，通过切面编程采集数据，类似于探针，而CAT的agent则更像是一个工具集，用于手动埋点&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;skywalking-1&#34;&gt;Skywalking&lt;/h2&gt;
&lt;p&gt;前戏这么多，终于开始进入主题，介绍今天的主角：Skywalking，不过通过之前的铺垫，我们基本都知道了Skywalking期望解决的问题以及总体的结构，下面我们则从细节来看Skywalking是怎么一步一步实现的。&lt;/p&gt;
&lt;h4 id=&#34;模块构成&#34;&gt;模块构成&lt;/h4&gt;
&lt;p&gt;首先，Skywalking进行了精准的领域模型划分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4qcfso8j31ol0u0te6.jpg&#34; alt=&#34;integration&#34;&gt;&lt;/p&gt;
&lt;p&gt;整个系统分为三部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;agent：采集tracing（调用链数据）和metric（指标）信息并上报&lt;/li&gt;
&lt;li&gt;OAP：收集tracing和metric信息通过analysis core模块将数据放入持久化容器中（ES，H2（内存数据库），mysql等等），并进行二次统计和监控告警&lt;/li&gt;
&lt;li&gt;webapp：前后端分离，前端负责呈现，并将查询请求封装为graphQL提交给后端，后端通过ribbon做负载均衡转发给OAP集群，再将查询结果渲染展示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而整个Skywalking（包括agent和OAP，而webapp后端业务非常简单主要就是认证和请求转发）均通过微内核+插件式的模式进行编码，代码结构和扩展性均非常强，具体设计可以参考： &lt;a href=&#34;https://linz.ink/skywalking/microcore/2018/11/26/how-to-build-micro-core-project-by-skywalking-style.html&#34;&gt;从Skywalking看如何设计一个微核+插件式扩展的高扩展框架&lt;/a&gt; ，Spring Cloud Gateway的GatewayFilterFactory的扩展也是通过这种plugin define的方式来实现的。&lt;/p&gt;
&lt;p&gt;Skywalking也提供了其他的一些特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置重载：支持通过jvm参数覆写默认配置，支持动态配置管理&lt;/li&gt;
&lt;li&gt;集群管理：这个主要体现在OAP，通过集群部署分担数据上报的流量压力和二次计算的计算压力，同时集群也可以通过配置切换角色，分别面向数据采集（collector）和计算（aggregator，alarm），需要注意的是agent目前不支持多collector负载均衡，而是随机从集群中选择一个实例进行数据上报&lt;/li&gt;
&lt;li&gt;支持k8s和mesh&lt;/li&gt;
&lt;li&gt;支持数据容器的扩展，例如官方主推是ES，通过扩展接口，也可以实现插件去支持其他的数据容器&lt;/li&gt;
&lt;li&gt;支持数据上报receiver的扩展，例如目前主要是支持gRPC接受agent的上报，但是也可以实现插件支持其他类型的数据上报（官方默认实现了对Zipkin，telemetry和envoy的支持）&lt;/li&gt;
&lt;li&gt;支持客户端采样和服务端采样，不过服务端采样最有意义&lt;/li&gt;
&lt;li&gt;官方制定了一个数据查询脚本规范：OAL（Observability Analysis Language），语法类似Linq，以简化数据查询扩展的工作量&lt;/li&gt;
&lt;li&gt;支持监控预警，通过OAL获取数据指标和阈值进行对比来触发告警，支持webhook扩展告警方式，支持统计周期的自定义，以及告警静默防止重复告警&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据容器&#34;&gt;数据容器&lt;/h4&gt;
&lt;p&gt;由于Skywalking并没有自己定制的数据容器或者使用多种数据容器增加复杂度，而是主要使用ElasticSearch（当然开源的基本上都是这样来保持简洁，例如Pinpoint也只使用了HBase），所以数据容器的特性以及自己数据结构基本上就限制了业务的上限，以ES为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES查询功能异常强大，在数据筛选方面碾压其他所有容器，在数据筛选潜力巨大（Skywalking默认的查询维度就比使用HBase的Pinpoint强很多）&lt;/li&gt;
&lt;li&gt;支持sharding分片和replicas数据备份，在高可用/高性能/大数据支持都非常好&lt;/li&gt;
&lt;li&gt;支持批量插入，高并发下的插入性能大大增强&lt;/li&gt;
&lt;li&gt;数据密度低，源于ES会提前构建大量的索引来优化搜索查询，这是查询功能强大和性能好的代价，但是链路跟踪往往有非常多的上下文需要记录，所以Skywalking把这些上下文二进制化然后通过Base64编码放入data_binary字段并且将字段标记为&lt;strong&gt;not_analyzed&lt;/strong&gt;来避免进行预处理建立查询索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来说，Skywalking尽量使用ES在大数据和查询方面的优势，同时尽量减少ES数据密度低的劣势带来的影响，从目前来看，ES在调用链跟踪方面是不二的数据容器，而在数据指标方面，ES也能中规中矩的完成业务，虽然和时序数据库相比要弱一些，但在PB级以下的数据支持也不会有太大问题。&lt;/p&gt;
&lt;h4 id=&#34;数据结构&#34;&gt;数据结构&lt;/h4&gt;
&lt;p&gt;如果说数据容器决定了上限，那么数据结构则决定了实际到达的高度。Skywalking的数据结构主要为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据维度（ES索引为skywalking_*_inventory)
&lt;ul&gt;
&lt;li&gt;service：服务&lt;/li&gt;
&lt;li&gt;instance：实例&lt;/li&gt;
&lt;li&gt;endpoint：接口&lt;/li&gt;
&lt;li&gt;network_adress：外部依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据内容
&lt;ul&gt;
&lt;li&gt;原始数据
&lt;ul&gt;
&lt;li&gt;调用链跟踪数据（调用链的trace信息，ES索引为skywalking_segment，Skywalking主要的数据消耗都在这里）&lt;/li&gt;
&lt;li&gt;指标（主要是jvm或者envoy的运行时指标，例如ES索引skywalking_instance_jvm_cpu）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二次统计指标
&lt;ul&gt;
&lt;li&gt;指标（按维度/时间二次统计出来的例如pxx、sla等指标，例如ES索引skywalking_database_access_p75_month）&lt;/li&gt;
&lt;li&gt;数据库慢查询记录（数据库索引：skywalking_top_n_database_statement）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关联关系（维度/指标之间的关联关系，ES索引为skywalking_*_relation_*)&lt;/li&gt;
&lt;li&gt;特别记录
&lt;ul&gt;
&lt;li&gt;告警信息（ES索引为skywalking_alarm_record）&lt;/li&gt;
&lt;li&gt;并发控制（ES索引为skywalking_register_lock）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中数量占比最大的就是调用链跟踪数据和各种指标，而这些数据均可以通过OAP设置过期时间，以降低历史数据的对磁盘占用和查询效率的影响。&lt;/p&gt;
&lt;h6 id=&#34;调用链跟踪数据&#34;&gt;调用链跟踪数据&lt;/h6&gt;
&lt;p&gt;作为Skywalking的核心数据，调用链跟踪数据（skywalking_segment）基本上奠定了整个系统的基础，而如果要详细的了解调用链跟踪的话，就不得不提到&lt;a href=&#34;https://opentracing.io/&#34;&gt;openTracing&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;openTracing基本上是目前开源调用链跟踪系统的一个事实标准，它制定了调用链跟踪的基本流程和基本的数据结构，同时也提供了各个语言的实现。如果用一张图来表现openTracing，则是如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q9qhwaj30ms0fdjrl.jpg&#34; alt=&#34;openTracing基本结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SpanContext：一个类似于MDC（Slfj)或者ThreadLocal的组件，负责整个调用链数据采集过程中的上下文保持和传递&lt;/li&gt;
&lt;li&gt;Trace：一次调用的完整记录
&lt;ul&gt;
&lt;li&gt;Span：一次调用中的某个节点/步骤，类似于一层堆栈信息，Trace是由多个Span组成，Span和Span之间也有父子或者并列的关系来标志这个节点/步骤在整个调用中的位置
&lt;ul&gt;
&lt;li&gt;Tag：节点/步骤中的关键信息&lt;/li&gt;
&lt;li&gt;Log：节点/步骤中的详细记录，例如异常时的异常堆栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Baggage：和SpanContext一样并不属于数据结构而是一种机制，主要用于跨Span或者跨实例的上下文传递，Baggage的数据更多是用于运行时，而不会进行持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以一个Trace为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q8omk9j30kg0bgabj.jpg&#34; alt=&#34;span间的关系&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先是外部请求调用A，然后A依次同步调用了B和C，而B被调用时会去同步调用D，C被调用的时候会依次同步调用E和F，F被调用的时候会通过异步调用G，G则会异步调用H，最终完成一次调用。&lt;/p&gt;
&lt;p&gt;上图是通过Span之间的依赖关系来表现一个Trace，而在时间线上，则可以有如下的表达：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q960foj30q009674i.jpg&#34; alt=&#34;span的调用顺序&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然，如果是同步调用的话，父Span的时间占用是包括子Span的时间消耗的。&lt;/p&gt;
&lt;p&gt;而落地到Skywalking中，我们以一条skywalking_segment的记录为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
	&amp;quot;trace_id&amp;quot;: &amp;quot;52.70.15530767312125341&amp;quot;,
	&amp;quot;endpoint_name&amp;quot;: &amp;quot;Mysql/JDBI/Connection/commit&amp;quot;,
	&amp;quot;latency&amp;quot;: 0,
	&amp;quot;end_time&amp;quot;: 1553076731212,
	&amp;quot;endpoint_id&amp;quot;: 96142,
	&amp;quot;service_instance_id&amp;quot;: 52,
	&amp;quot;version&amp;quot;: 2,
	&amp;quot;start_time&amp;quot;: 1553076731212,
	&amp;quot;data_binary&amp;quot;: &amp;quot;CgwKCjRGnPvp5eikyxsSXhD///////////8BGMz62NSZLSDM+tjUmS0wju8FQChQAVgBYCF6DgoHZGIudHlwZRIDc3FsehcKC2RiLmluc3RhbmNlEghyaXNrZGF0YXoOCgxkYi5zdGF0ZW1lbnQYAiA0&amp;quot;,
	&amp;quot;service_id&amp;quot;: 2,
	&amp;quot;time_bucket&amp;quot;: 20190320181211,
	&amp;quot;is_error&amp;quot;: 0,
	&amp;quot;segment_id&amp;quot;: &amp;quot;52.70.15530767312125340&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trace_id：本次调用的唯一id，通过snowflake模式生成&lt;/li&gt;
&lt;li&gt;endpoint_name：被调用的接口&lt;/li&gt;
&lt;li&gt;latency：耗时&lt;/li&gt;
&lt;li&gt;end_time：结束时间戳&lt;/li&gt;
&lt;li&gt;endpoint_id：被调用的接口的唯一id&lt;/li&gt;
&lt;li&gt;service_instance_id：被调用的实例的唯一id&lt;/li&gt;
&lt;li&gt;version：本数据结构的版本号&lt;/li&gt;
&lt;li&gt;start_time：开始时间戳&lt;/li&gt;
&lt;li&gt;data_binary：里面保存了本次调用的所有Span的数据，序列化并用Base64编码，不会进行分析和用于查询&lt;/li&gt;
&lt;li&gt;service_id：服务的唯一id&lt;/li&gt;
&lt;li&gt;time_bucket：调用所处的时段&lt;/li&gt;
&lt;li&gt;is_error：是否失败&lt;/li&gt;
&lt;li&gt;segment_id：数据本身的唯一id，类似于主键，通过snowflake模式生成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里可以看到，目前Skywalking虽然相较于Pinpoint来说查询的维度要多一些，但是也很有限，而且除了endPoint，并没有和业务有关联的字段，只能通过时间/服务/实例/接口/成功标志/耗时来进行非业务相关的查询，如果后续要增强业务相关的搜索查询的话，应该还需要增加一些用于保存动态内容（如messageId，orderId等业务关键字）的字段用于快速定位。&lt;/p&gt;
&lt;h6 id=&#34;指标&#34;&gt;指标&lt;/h6&gt;
&lt;p&gt;指标数据相对于Tracing则要简单得多了，一般来说就是指标标志、时间戳、指标值，而Skywalking中的指标有两种：一种是采集的原始指标值，例如jvm的各种运行时指标（例如cpu消耗、内存结构、GC信息等）；一种是各种二次统计指标（例如tp性能指标、SLA等，当然也有为了便于查询的更高时间维度的指标，例如基于分钟、小时、天、周、月）&lt;/p&gt;
&lt;p&gt;例如以下是索引skywalking_endpoint_cpm_hour中的一条记录，用于标志一个小时内某个接口的cpm指标：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
	&amp;quot;total&amp;quot;: 8900,
	&amp;quot;service_id&amp;quot;: 5,
	&amp;quot;time_bucket&amp;quot;: 2019031816,
	&amp;quot;service_instance_id&amp;quot;: 5,
	&amp;quot;entity_id&amp;quot;: &amp;quot;7&amp;quot;,
	&amp;quot;value&amp;quot;: 148
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;各个字段的释义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;total：一分钟内的调用总量&lt;/li&gt;
&lt;li&gt;service_id：所属服务的唯一id&lt;/li&gt;
&lt;li&gt;time_bucket：统计的时段&lt;/li&gt;
&lt;li&gt;service_instance_id：所属实例的唯一id&lt;/li&gt;
&lt;li&gt;entity_id：接口（endpoint）的唯一id&lt;/li&gt;
&lt;li&gt;value：cpm的指标值（cpm=call per minute，即total/60）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工程实现&#34;&gt;工程实现&lt;/h4&gt;
&lt;p&gt;Skywalking的工程实现堪比Dubbo，框架设计和代码质量都达到非常高的水准，以dubbo为例，即使2012年发布的老版本放到当今，其设计和编码看起来也依然赏心悦目，设计简洁但是覆盖了所有的核心需求，同时又具备非常强的扩展性，二次开发非常简单，然而却又不会像Spring那样过度封装（当然Spring作为一个更加高度通用的框架，更高的封装也是有必要的）导致代码阅读异常困难。&lt;/p&gt;
&lt;h6 id=&#34;agent&#34;&gt;agent&lt;/h6&gt;
&lt;p&gt;agent（apm-sniffer）是Skywalking的Java探针实现，主要负责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采集应用实例的jvm指标&lt;/li&gt;
&lt;li&gt;通过切向编程进行数据埋点，采集调用链数据&lt;/li&gt;
&lt;li&gt;通过RPC将采集的数据上报&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，agent还实现了客户端采样，不过在APM监控系统里进行客户端数据采样都是没有灵魂的，所以这里就不再赘述了。&lt;/p&gt;
&lt;p&gt;首先，agent通过 &lt;em&gt;org.apache.skywalking.apm.agent.core.boot.BootService&lt;/em&gt; 实现了整体的插件化，agent启动会加载所有的BootService实现，并通过 &lt;em&gt;ServiceManager&lt;/em&gt; 来管理这些插件的生命周期，采集jvm指标、gRPC连接管理、调用链数据维护、数据上报OAP这些服务均是通过这种方式扩展。&lt;/p&gt;
&lt;p&gt;然后，agent还通过bytebuddy以javaagent的模式，通过字节码增强的机制来构造AOP环境，再提供PluginDefine的规范方便探针的开发，最终实现非侵入性的数据埋点，采集调用链数据。&lt;/p&gt;
&lt;p&gt;最终落地到代码上则异常清晰：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通过bytebuddy的AgentBuilder构造javaagent增强classLoader
new AgentBuilder.Default(byteBuddy)
    .ignore( //忽略这些包的内容，不进行增强
        nameStartsWith(&amp;quot;net.bytebuddy.&amp;quot;)
        .or(nameStartsWith(&amp;quot;org.slf4j.&amp;quot;))
        .or(nameStartsWith(&amp;quot;org.apache.logging.&amp;quot;))
        .or(nameStartsWith(&amp;quot;org.groovy.&amp;quot;))
        .or(nameContains(&amp;quot;javassist&amp;quot;))
        .or(nameContains(&amp;quot;.asm.&amp;quot;))
        .or(nameStartsWith(&amp;quot;sun.reflect&amp;quot;))
        .or(allSkyWalkingAgentExcludeToolkit())
        .or(ElementMatchers.&amp;lt;TypeDescription&amp;gt;isSynthetic()))
    //通过pluginFinder加载所有的探针扩展，并获取所有可以增强的class
    .type(pluginFinder.buildMatch())
    //按照pluginFinder的实现，去改变字节码增强类
    .transform(new Transformer(pluginFinder))
    //通过listener订阅增强的操作记录，方便调试
    .with(new Listener())
    .installOn(instrumentation);

try {
    //加载所有的service实现并启动
    ServiceManager.INSTANCE.boot();
} catch (Exception e) {
    logger.error(e, &amp;quot;Skywalking agent boot failure.&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;agent也提供了非常简单的扩展实现机制，以增强一个普通类的方法为例，首先你需要定义一个切向点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface InstanceMethodsInterceptPoint {

    //定义切向方法的适配器，符合适配器的class将被增强
    ElementMatcher&amp;lt;MethodDescription&amp;gt; getMethodsMatcher();

    //增强的具体实现类，classReference
    String getMethodsInterceptor();

    //是否重写参数
    boolean isOverrideArgs();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后你还需要一个增强的实现类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface InstanceMethodsAroundInterceptor {

    //方法真正执行前执行
    void beforeMethod(EnhancedInstance objInst, Method method, Object[] allArguments, Class&amp;lt;?&amp;gt;[] argumentsTypes,
        MethodInterceptResult result) throws Throwable;

    //方法真正执行后执行
    Object afterMethod(EnhancedInstance objInst, Method method, Object[] allArguments, Class&amp;lt;?&amp;gt;[] argumentsTypes,
        Object ret) throws Throwable;

    //当异常发生时执行
    void handleMethodException(EnhancedInstance objInst, Method method, Object[] allArguments,
        Class&amp;lt;?&amp;gt;[] argumentsTypes,
        Throwable t);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般在执行前和执行后进行数据埋点，就可以采集到想要的数据，当然实际编程要稍微复杂一点，不过官方也实现了对应的abstract类和数据埋点工具类，所以探针的二次开发在Skywalking这个级别确实是非常简单，只需要处理好资源占用和并发问题即可。真正的难点是要对需要增强的对象非常了解，熟悉其运作机制，才能找准切向点，既要所有的流程都需要经过这个点，又可以抓取到期望抓取的上下文信息。同时，多版本的适配和测试也是非常大的工作量，官方虽然提供witness的机制（通过验证某个class是否存在来验证版本），但是作为影响全局的探针，开发和测试都是需要慎之又慎的。&lt;/p&gt;
&lt;h6 id=&#34;oap&#34;&gt;OAP&lt;/h6&gt;
&lt;p&gt;同agent类似，OAP作为Skywalking最核心的模块，也实现了自己的扩展机制，不过在这里叫做Module，具体可以参考library-module，在module的机制下，Skywalking实现了自己必须核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;core：整个OAP核心业务（remoting、cluster、storage、analysis、query、alarm）的规范和接口&lt;/li&gt;
&lt;li&gt;cluster：集群管理的具体实现&lt;/li&gt;
&lt;li&gt;storage：数据容器的具体实现&lt;/li&gt;
&lt;li&gt;query：为前端提供的查询接口的具体实现&lt;/li&gt;
&lt;li&gt;receiver：接收探针上报数据的接收器的具体实现&lt;/li&gt;
&lt;li&gt;alarm：监控告警的具体实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及一个可选组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;telemetry：用于监控OAP自身的健康状况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而前面提到的OAP的高扩展性则体现在核心业务的规范均定义在了core中，如果有需要自己扩展的，只需要自己单独做自己的实现，而不需要做侵入式的改动，最典型的示例则是官方支持的storage，不仅支持单机demo的内存数据库H2和经典的ES，连目前开源的Tidb都可以接入。&lt;/p&gt;
&lt;h2 id=&#34;初步实践&#34;&gt;初步实践&lt;/h2&gt;
&lt;p&gt;对于Skywalking的实践我们经历了三个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线下测试&lt;/li&gt;
&lt;li&gt;第一次生产环境小规模测试&lt;/li&gt;
&lt;li&gt;第二次生产环境小规模测试+全量接入&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;线下测试&#34;&gt;线下测试&lt;/h4&gt;
&lt;h6 id=&#34;环境&#34;&gt;环境&lt;/h6&gt;
&lt;p&gt;由于是线下测试，所以我们直接使用物理机（E5-2680v2 x2, 128G)虚拟了一个集群（实际性能相比云服务器应该偏好一些）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES：单机实例，v6.5，4C8G，jvm内存分配为4G&lt;/li&gt;
&lt;li&gt;OAP：单机实例，v6.1.0-SNAPSHOT，4C8G，jvm内存分配为4G&lt;/li&gt;
&lt;li&gt;应用：基于SpringCloud的4个测试实例,调用关系为A-&amp;gt;B-&amp;gt;C-&amp;gt;D，QPS为200&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;测试结果&#34;&gt;测试结果&lt;/h6&gt;
&lt;p&gt;拓扑图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q5cqinj30o90dx3za.jpg&#34; alt=&#34;测试拓扑图&#34;&gt;&lt;/p&gt;
&lt;p&gt;OAP机器监控：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4qanxy5j30fn0gb750.jpg&#34; alt=&#34;OAP监控&#34;&gt;&lt;/p&gt;
&lt;p&gt;ES机器监控：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4qbzgx2j30fn0js3zn.jpg&#34; alt=&#34;es机器监控&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务监控面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q0e7zwj30t20ta0vh.jpg&#34; alt=&#34;服务面板&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中一个调用链记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q60h0uj30oo0dt0u5.jpg&#34; alt=&#34;测试调用链&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，Skywalking非常依赖CPU（不论是OAP还是ES），同时对于网络IO也有一定的要求，至于ES的文件IO在可接受范围内，毕竟确实有大量内容需要持久化。测试结果也基本达到预期要求，调用链和各个指标的监控都工作良好。&lt;/p&gt;
&lt;h4 id=&#34;第一次生产环境测试&#34;&gt;第一次生产环境测试&lt;/h4&gt;
&lt;p&gt;在线下测试之后，我们再进行了一次基于实际业务针对探针的测试，测试没有发现探针的异常问题，也没有影响业务的正常运作，同时对于jvm实例影响也不是很大，CPU大概提高了5%左右，并不很明显。在这个基础上我们选择了线上的一台服务器，进行了我们第一次生产环境的测试。&lt;/p&gt;
&lt;h6 id=&#34;环境-1&#34;&gt;环境&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;ES：基于现有的一个ES集群，node x 3，v6.0&lt;/li&gt;
&lt;li&gt;OAP：2C4G x 2，v6.1.0-SNAPSHOT，jvm内存分配为2G&lt;/li&gt;
&lt;li&gt;应用：两个jvm实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试时间：03.11-03.16&lt;/p&gt;
&lt;h6 id=&#34;测试结果-1&#34;&gt;测试结果&lt;/h6&gt;
&lt;p&gt;业务机器负载情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q7aczcj30s20ht77p.jpg&#34; alt=&#34;dp1-cpu&#34;&gt;&lt;/p&gt;
&lt;p&gt;从最敏感的CPU指标上来看，增加agent并没有导致可见的CPU使用率的变化，而其他的内存、网络IO、连接数也基本没有变化。&lt;/p&gt;
&lt;p&gt;OAP负载情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4qbjk28j30rz0httax.jpg&#34; alt=&#34;第一次测试CPU&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q6jo3sj30rs0lfq5n.jpg&#34; alt=&#34;第一次测试网络&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到机器的CPU和网络均有较大的波动，但是也都没有真正打爆服务器，但是我们的实例却经常出现两种日志：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One trace segment has been abandoned, cause by buffer is full.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Collector traceSegment service doesn&amp;rsquo;t response in xxx seconds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过阅读源码发现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;agent和OAP只会使用一个长连接阻塞式的交换数据，如果某次数据交换没有得到响应，则会阻塞后续的上报流程（一般长连接的RPC请求会在数据传输期间互相阻塞，但是不会在等待期间互相阻塞，当然这也是源于agent并没有并发上报的机制），所以一旦OAP在接收数据的过程中发生阻塞，就会导致agent本地的缓冲区满，最终只能将监控数据直接丢弃防止内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而导致OAP没有及时响应的一方面是OAP本身性能不够（OAP需要承担大量的二次统计工作，通过Jstack统计，长期有超过几十个线程处于RUNNABLE状态，据吴晟描述目前OAP都是高性能模式，后续将会提供配置来支持低性能模式），另一方面可能是ES批量插入效率不够，因此我们修改了OAP的批量插入参数来增加插入频率，降低单次插入数量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:2000 -&amp;gt; 20} # Execute the bulk every 2000 requests&lt;/li&gt;
&lt;li&gt;bulkSize: ${SW_STORAGE_ES_BULK_SIZE:20 -&amp;gt; 2} # flush the bulk every 20mb&lt;/li&gt;
&lt;li&gt;flushInterval: ${SW_STORAGE_ES_FLUSH_INTERVAL:10 -&amp;gt; 2} # flush the bulk every 10 seconds whatever the number of requests&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然 &lt;em&gt;service doesn&amp;rsquo;t response&lt;/em&gt; 出现的频率明显降低，但是依然还是会偶尔出现，而每一次出现都会伴随大量的  &lt;em&gt;trace segment has been abandoned&lt;/em&gt; ，推测OAP和ES可能都存在性能瓶颈（应该进行更进一步的诊断确定问题，不过当时直接和吴晟沟通，确认确实OAP非常消耗CPU资源，考虑到当时部署只是2C，并且还部署有其他业务，就没有进一步的测试）。&lt;/p&gt;
&lt;p&gt;同时，在频繁的数据丢弃过程中，也偶发了一个bug：当agent上报数据超时并且大量丢弃数据之后，即使后续恢复正常也能通过日志看到数据正常上报，在查询界面查询的时候，会查不到这个实例上报的数据，不过在重启OAP和agent之后，之前上报的数据又能查询到，这个也和吴晟沟通过，没有其他的案例，后续想重现却也一直没有成功。&lt;/p&gt;
&lt;p&gt;而同时还发现两个更加严重的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们使用的是线上已经部署好的ES集群，其版本只有6.0，而新的Skywalking使用了6.3的查询特性，导致很多查询执行报错，只能使用最简单的查询&lt;/li&gt;
&lt;li&gt;我们的kafka集群版本也非常古老，不支持v1或者更高版本的header，而kafka的探针强依赖header来传输上下文信息，导致kafka客户端直接报错影响业务，所以也立即移除了kafka的探针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这一次测试中，我们基本确认了agent对于应用的影响，同时也发现了一些我们和Skywalking的一些问题，留待后续测试确认。&lt;/p&gt;
&lt;h4 id=&#34;第二次生产环境测试&#34;&gt;第二次生产环境测试&lt;/h4&gt;
&lt;p&gt;为了排除性能和ES版本的影响，测试Skywalking本身的可用性，参考吴晟的建议（这也是在最初技术选型的时候没有选择Pinpoint和CAT的部分原因：一方面Skywalking的功能符合我们的要求，更重要的是有更加直接和效率的和项目维护者直接沟通的渠道），所以这一次我们新申请了ES集群和OAP机器。&lt;/p&gt;
&lt;h6 id=&#34;环境-2&#34;&gt;环境&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;ES：腾讯云托管ES集群，4C16G x 3 SSD，v6.4&lt;/li&gt;
&lt;li&gt;OAP：16C32G，standalone，jvm分配24G&lt;/li&gt;
&lt;li&gt;应用：2~8个jvm实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试时间：03.18-至今&lt;/p&gt;
&lt;h6 id=&#34;测试结果-2&#34;&gt;测试结果&lt;/h6&gt;
&lt;p&gt;OAP负载情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q7qh37j30nh0hmmzv.jpg&#34; alt=&#34;二次测试&#34;&gt;&lt;/p&gt;
&lt;p&gt;ES集群负载：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4q6sscbj30uo0l80wj.jpg&#34; alt=&#34;二测es监控&#34;&gt;&lt;/p&gt;
&lt;p&gt;测试过程中，我们先接入了一台机器上的两个实例，完全没有遇到一测中的延迟或者数据丢弃的问题，三天后我们又接入了另外两台机器的4个实例，这之后两天我们又接入了另外两台机器的2个实例。依然没有遇到一测中的延迟或者数据丢弃的问题。&lt;/p&gt;
&lt;p&gt;而ES负载的监控也基本验证了一测延迟的问题，Skywalking由于较高的并发插入，对于ES的性能压力很大（批量插入时需要针对每条数据分析并且构建查询索引），大概率是ES批量插入性能不够导致延迟，考虑到我们仅仅接入了8个实例，日均segment插入量大概5000万条（即日均5000万次独立调用），如果想支持更大规模的监控，对于ES容量规划势必要留够足够的冗余。同时OAP和ES集群的网络开销也不容忽视，在支撑大规模的监控时，需要集群并且receiver和aggregattor分离部署来分担网络IO的压力。&lt;/p&gt;
&lt;p&gt;而在磁盘容量占用上，我们设置的原始数据7天过期，目前刚刚开始滚动过期，目前segment索引已经累计了314757240条记录总计158G数据，当然我们目前异常记录较少，如果异常记录较多的话，其磁盘开销将会急剧增加（span中会记录异常堆栈信息）。而由于选择的SSD，磁盘的写入和查询性能都很高，即使只有3个节点，也完全没有任何压力。&lt;/p&gt;
&lt;p&gt;而在新版本的ES集群下，Skywalking的所有查询功能都变得可用，和我们之前自己的单独编写的异常指标监控都能完美对照。当然我们也遇到一个问题：Skywalking仅采集了调用记录，但是对于调用过程中的过程数据，除了异常堆栈其他均没有采集，导致真的出现异常也缺少充足的上下文信息还原现场，于是我们扩展了Skywalking的两个探针（我们项目目前重度依赖的组件）：OkHttp（增加对requestBody和responseBody的采集）和SpringMVC（增加了对requestBody的采集），目前工作正常，如果进一步的增加其他的探针，采集到足够的数据，那么我们基本可以脱离ELK了。&lt;/p&gt;
&lt;p&gt;而OAP方面，CPU和内存的消耗远远低于预期的估计，CPU占用率一直较低，而分配的24G内存也仅使用了10+G，完全可以支持更大规模的接入量，不过在网络IO方面可能存在一定的风险，推测应该8C16G的容器就足以支持十万CPM级别的数据接入。&lt;/p&gt;
&lt;p&gt;当然我们在查询也遇到了一些瓶颈，最大的问题就是无法精确的命中某一条调用记录，就如前面的分析，因为segment的数据结构问题，无法进行面向业务的查询（例如messageId、requestId、orderId等），所以如果想精确匹配某一次调用请求，需要通过各个维度的条件约束慢慢缩小范围最后定位。&lt;/p&gt;
&lt;h2 id=&#34;skywalking展望&#34;&gt;Skywalking展望&lt;/h2&gt;
&lt;p&gt;通过上述对Skywalking的剖析和实践，Skywalking确实是一个优秀的APM+调用链跟踪监控系统，能够覆盖大部分使用场景，让研发和运维能够更加实时/准实时的了解线上服务的运行情况。当然Skywailking也不是尽善尽美，例如下面就是个人觉得目前可见的不满足我们期望的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据准实时通过gRPC上报，本地缓存的瓶颈（当然官方主要是为了简化模型，减少依赖，否则Skywalking还依赖ELK就玩得有点大了）
&lt;ul&gt;
&lt;li&gt;缓存队列的长度，过长占据内存，过短容易buffer满丢弃数据&lt;/li&gt;
&lt;li&gt;优雅停机同时又不丢失缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据上报需要在起点上报，链路回传的时候需要携带SPAN及子SPAN的信息，当链路较长或者SPAN保存的信息较多时，会额外消耗一定的带宽&lt;/li&gt;
&lt;li&gt;skywalking更多是一个APM系统而不是分布式调用链跟踪系统
&lt;ul&gt;
&lt;li&gt;在整个链路的探针上均缺少输入输出的抓取&lt;/li&gt;
&lt;li&gt;在调用链的筛查上并没用进行增强，并且体现在数据结构的设计，例如TAG信息均保存在SPAN信息中，而SPAN信息均被BASE64编码作为数据保存，无法检索，最终trace的筛查只能通过时间/traceId/service/endPoint/state进行非业务相关的搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;skywalking缺少对三方接口依赖的指标，这个对于系统稳定往往非常重要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而作为一个初级的使用者，个人觉得我们可以使用有限的人力在以下方向进行扩展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加receiver：整合ELK，通过日志采集采集数据，降低异构系统的采集开发成本&lt;/li&gt;
&lt;li&gt;优化数据结构，提供基于业务关键数据的查询接口&lt;/li&gt;
&lt;li&gt;优化探针，采集更多的业务数据，争取代替传统的ELK日志简单查询，绝大部分异常诊断和定位均可以通过Skywalking即可完成&lt;/li&gt;
&lt;li&gt;增加业务指标监控的模式，能够自定义业务指标（目前官方已经在实现 &lt;a href=&#34;https://github.com/apache/incubator-skywalking/blob/master/docs/en/setup/backend/metric-exporter.md&#34;&gt;Metric Exporter&lt;/a&gt; ）&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Zh: APM巅峰对决：SkyWalking P.K. Pinpoint</title>
      <link>/zh/2019-02-24-skywalking-pk-pinpoint/</link>
      <pubDate>Sun, 24 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/zh/2019-02-24-skywalking-pk-pinpoint/</guid>
      <description>
        
        
        &lt;blockquote&gt;
&lt;p&gt;作者：王振飞, 写于：2019-02-24
&lt;strong&gt;说明&lt;/strong&gt;：此文是个人所写，版本归属作者，代表个人观点，仅供参考，不代表skywalking官方观点。
&lt;strong&gt;说明&lt;/strong&gt;：本次对比基于skywalking-6.0.0-GA和Pinpoint-1.8.2（截止2019-02-19最新版本）。另外，我们这次技术选型直接否定了Zipkin，其最大原因是它对代码有侵入性，CAT也是一样。这是我们所完全无法接受的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这应该是目前最优秀的两款开源APM产品了，而且两款产品都通过字节码注入的方式，实现了对代码&lt;strong&gt;完全无任何侵入&lt;/strong&gt;，他们的对比信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4kjo1okj30in0q3gnb.jpg&#34; alt=&#34;Pinpoint P.K. skywalking&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OAP说明&lt;/strong&gt;: skywalking6.x才有OAP这个概念，skywalking5.x叫collector。&lt;/p&gt;
&lt;p&gt;接下来，对每个PK项进行深入分析和对比。更多精彩和首发内容请关注公众号：【&lt;strong&gt;阿飞的博客&lt;/strong&gt;】。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;社区比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一点上面skywalking肯定完胜。一方面，skywalking已经进入apache孵化，社区相当活跃。而且项目发起人是中国人，我们能够进入官方群（Apache SkyWalking交流群：&lt;code&gt;392443393&lt;/code&gt;）和项目发起人吴晟零距离沟通，很多问题能第一时间得到大家的帮助（玩过开源的都知道，这个价值有多大）。
而Pinpoint是韩国人开发的，免不了有沟通障碍。至于github上最近一年的commit频率，skywalking和Pinpoint旗鼓相当，都是接近20的水平:
&lt;img src=&#34;0081Kckwly1gkl4kone2qj30rs0eudgj.jpg&#34; alt=&#34;Insight commit&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，社区方面，skywalking更胜一筹。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;支持语言比较&#34;&gt;&lt;strong&gt;支持语言比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Pinpoint只支持Java和PHP，而skywalking支持5种语言：Java, C#, PHP, Node.js, Go。如果公司的服务涉及到多个开发语言，那么skywalking会是你更好的选择。并且，如果你要实现自己的探针（比如python语言），skywalking的二次开发成本也比Pinpoint更低。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：Github上有开发者为Pinpoint贡献了对Node.js的支持，请戳链接：https://github.com/peaksnail/pinpoint-node-agent。但是已经停止维护，几年没更新了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所以，支持语言方面，skywalking更胜一筹&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;协议比较&#34;&gt;&lt;strong&gt;协议比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;SkyWalking支持gRPC和http，不过建议使用gRPC，skywalking6.x版本已经不提供http方式（但是还会保留接收5.x的数据），以后会考虑删除。
而Pinpoint使用的是thrift协议。
协议本身没有谁好谁坏。&lt;/p&gt;
&lt;h3 id=&#34;存储比较重要&#34;&gt;&lt;strong&gt;存储比较(重要)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;笔者认为，存储是skywalking和Pinpoint最大的差异所在，因为底层存储决定了上层功能。&lt;/p&gt;
&lt;p&gt;Pinpoint只支持HBase，且扩展代价较大。这就意味着，如果选择Pinpoint，还要有能力hold住一套HBase集群（daocloud从Pinpoint切换到skywalking就是因为HBase的维护代价有点大）。在这方面，skywalking支持的存储就多很多，这样的话，技术选型时可以根据团队技术特点选择合适的存储，而且还可以自行扩展（不过生产环境上应该大部分是以es存储为主）。&lt;/p&gt;
&lt;p&gt;Pinpoint只支持HBase的另一个缺陷就是，HBase本身查询能力有限（HBase只能支持三种方式查询：RowKey精确查找，SCAN范围查找，全表扫描）限制了Pinpoint的查询能力，所以其支持的查询一定是在时间的基础上（Pinpoint通过鼠标圈定一个时间范围后查看这个范围内的Trace信息）。而skywalking可以多个维度任意组合查询，例如：时间范围，服务名，Trace状态，请求路径，TraceId等。&lt;/p&gt;
&lt;p&gt;另外，Pinpoint和skywalking都支持TTL，即历史数据保留策略。skywalking是在OAP模块的application.yml中配置从而指定保留时间。而Pinpoint是通过HBase的ttl功能实现，通过Pinpoint提供的hbase脚本&lt;code&gt;https://github.com/naver/pinpoint/blob/master/hbase/scripts/hbase-create.hbase&lt;/code&gt;可以看到：ApplicationTraceIndex配置了&lt;code&gt;TTL =&amp;gt; 5184000&lt;/code&gt;，SqlMetaData_Ver2配合了&lt;code&gt;TTL =&amp;gt; 15552000&lt;/code&gt;，单位是秒。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：es并不是完全碾压HBase，es和HBase没有绝对的好和坏。es强在检索能力，存储能力偏弱(千亿以下，es还是完全有能力hold的住的)。HBase强在存储能力，检索能力偏弱。如果搜集的日志量非常庞大，那么es存储就比较吃力。当然，没有蹩脚的中间件，只有蹩脚的程序员，无论是es还是HBase，调优才是最关键的。同样的，如果对检索能力有一定的要求，那么HBase肯定满足不了你。所以，又到了根据你的业务和需求决定的时刻了，trade-off真是无所不在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4kqmtxej30nt0mb74w.jpg&#34; alt=&#34;skywalking trace query&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ui比较&#34;&gt;&lt;strong&gt;UI比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Pinpoint的UI确实比skywalking稍微好些，尤其是服务的拓扑图展示。不过daocloud根据Pinpoint的风格为skywalking定制了一款UI。请戳链接：https://github.com/TinyAllen/rocketbot，项目介绍是：&lt;code&gt;rocketbot: A UI for Skywalking&lt;/code&gt;。截图如下所示；
&lt;img src=&#34;0081Kckwly1gkl4kmm7q3j30yg0jmgmm.jpg&#34; alt=&#34;rocketbot: A UI for Skywalking&#34;&gt;
&lt;strong&gt;所以，只比较原生UI的话，Pinpoint更胜一筹。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;扩展性比较&#34;&gt;&lt;strong&gt;扩展性比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Pinpoint好像设计之初就没有过多考虑扩展性，无论是底层的存储，还是自定义探针实现等。而skywalking核心设计目标之一就是&lt;strong&gt;Pluggable&lt;/strong&gt;，即可插拔。&lt;/p&gt;
&lt;p&gt;以存储为例，pinpoint完全没有考虑扩展性，而skywalking如果要自定义实现一套存储，只需要定义一个类实现接口&lt;code&gt;org.apache.skywalking.oap.server.library.module.ModuleProvider&lt;/code&gt;，然后实现一些DAO即可。至于Pinpoint则完全没有考虑过扩展底层存储。&lt;/p&gt;
&lt;p&gt;再以实现一个自己的探针为例（比如我要实现python语言的探针），Pinpoint选择thrift作为数据传输协议标准，而且为了节省数据传输大小，在传递常量的时候也尽量使用数据参考字典，传递一个数字而不是直接传递字符串等等。这些优化也增加了系统的复杂度：包括使用 Thrift 接口的难度、UDP 数据传输的问题、以及数据常量字典的注册问题等等。Pinpoint发展这么年才支持Java和PHP，可见一斑。而skywalking的数据接口就标准很多，并且支持OpenTracing协议，除了官方支持Java以外，C#、PHP和Node.js的支持都是由社区开发并维护。&lt;/p&gt;
&lt;p&gt;还有后面会提到的告警，skywalking的可扩展性也要远好于Pinpoint。&lt;/p&gt;
&lt;p&gt;最后，Pinpoint和skywalking都支持插件开发，Pinpoint插件开发参考：http://naver.github.io/pinpoint/1.8.2/plugindevguide.html。skywalking插件开发参考：https://github.com/apache/incubator-skywalking/blob/master/docs/en/guides/Java-Plugin-Development-Guide.md。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，扩展性方面skywalking更胜一筹&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;告警比较&#34;&gt;&lt;strong&gt;告警比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Pinpoint和skywalking都支持自定义告警规则。&lt;/p&gt;
&lt;p&gt;但是恼人的是，Pinpoint如果要配置告警规则，还需要安装MySQL(配置告警时的用户，用户组信息以及告警规则都持久化保存在MySQL中)，这就导致Pinpoint的维护成本又高了一些，既要维护HBase又要维护MySQL。&lt;/p&gt;
&lt;p&gt;Pinpoint支持的告警规则有：SLOW COUNT|RATE, ERROR COUNT|RATE, TOTAL COUNT, SLOW COUNT|RATE TO CALLEE, ERROR COUNT|RATE TO CALLEE, ERROR RATE TO CALLEE, HEAP USAGE RATE, JVM CPU USAGE RATE, DATASOURCE CONNECTION USAGE RATE。&lt;/p&gt;
&lt;p&gt;Pinpoint每3分钟周期性检查过去5分钟的数据，如果有符合规则的告警，就会发送sms/email给用户组下的所有用户。需要说明的是，实现发送sms/email的逻辑需要自己实现，Pinpoint只提供了接口&lt;code&gt;com.navercorp.pinpoint.web.alarm.AlarmMessageSender&lt;/code&gt;。并且Pinpoint发现告警持续时，会递增发送sms/email的时间间隔 3min -&amp;gt; 6min -&amp;gt; 12min -&amp;gt; 24min，防止sms/email狂刷。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Pinpoint告警参考&lt;/strong&gt;：http://naver.github.io/pinpoint/1.8.2/alarm.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;skywalking配置告警不需要引入任何其他存储。skywalking在config/alarm-settings.xml中可以配置告警规则，告警规则支持自定义。&lt;/p&gt;
&lt;p&gt;skywalking支持的告警规则（配置项中的名称是indicator-name）有：service_resp_time, service_sla, service_cpm, service_p99, service_p95, service_p90, service_p75, service_p50, service_instance_sla, service_instance_resp_time, service_instance_cpm, endpoint_cpm, endpoint_avg, endpoint_sla, endpoint_p99, endpoint_p95, endpoint_p90, endpoint_p75, endpoint_p50。&lt;/p&gt;
&lt;p&gt;Skywalking通过HttpClient的方式远程调用在配置项webhooks中定义的告警通知服务地址。skywalking也支持silence-period配置，假设在TN这个时间点触发了告警，那么TN -&amp;gt; TN+period 这段时间内不会再重复发送该告警。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;skywalking告警参考&lt;/strong&gt;：https://github.com/apache/incubator-skywalking/blob/master/docs/en/setup/backend/backend-alarm.md。目前只支持official_analysis.oal脚本中Service, Service Instance, Endpoint scope的metric，其他scope的metric需要等待后续扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pinpoint和skywalking都支持常用的告警规则配置，但是skywalking采用webhooks的方式就灵活很多：短信通知，邮件通知，微信通知都是可以支持的。而Pinpoint只能sms/email通知，并且还需要引入MySQL存储，增加了整个系统复杂度。所以，&lt;strong&gt;告警方面，skywalking更胜一筹&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;jvm监控&#34;&gt;&lt;strong&gt;JVM监控&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;skywalking支持监控：Heap, Non-Heap, GC(YGC和FGC)。
Pinpoint能够监控的指标主要有：Heap, Non-Heap, FGC, DirectBufferMemory, MappedBufferMemory，但是没有YGC。另外，Pinpoint还支持多个指标同一时间点查看的功能。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4kp7botj30yg0i5jwg.jpg&#34; alt=&#34;Pinpoint JVM inspector&#34;&gt;
&lt;strong&gt;所以，对JVM的监控方面，Pinpoint更胜一筹。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;服务监控&#34;&gt;&lt;strong&gt;服务监控&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;包括操作系统，和部署的服务实例的监控。
Pinpoint支持的维度有：CPU使用率，Open File Descriptor，数据源，活动线程数，RT，TPS。
skywalking支持的维度有：CPU使用率，SLA，RT，CPM（Call Per Minutes）。
所以，这方面两者旗鼓相当，没有明显的差距。&lt;/p&gt;
&lt;h3 id=&#34;跟踪粒度比较&#34;&gt;&lt;strong&gt;跟踪粒度比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Pinpoint在这方面做的非常好，跟踪粒度非常细。如下图所示，是Pinpoint对某个接口的trace信息：
&lt;img src=&#34;0081Kckwly1gkl4kppkcjj30yg0je7ck.jpg&#34; alt=&#34;Pinpoint trace detail&#34;&gt;&lt;/p&gt;
&lt;p&gt;而同一个接口skywalking的trace信息如下图所示：
&lt;img src=&#34;0081Kckwly1gkl4knyttmj30yg091dhi.jpg&#34; alt=&#34;skywalking trace detail&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4kq1n8vj30yg0bggna.jpg&#34; alt=&#34;skywalking trace sql&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;: 此截图是skywalking加载了插件&lt;code&gt;apm-spring-annotation-plugin-6.0.0-GA.jar&lt;/code&gt;（这个插件允许跟踪加了@Bean, @Service, @Component and @Repository注解的spring context中的bean的方法）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过对比发现，&lt;strong&gt;在跟踪粒度方面，Pinpoint更胜一筹&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;过滤追踪&#34;&gt;&lt;strong&gt;过滤追踪&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Pinpoint和skywalking都可以实现，而且配置的表达式都是基于ant风格。
Pinpoint在Web UI上配置 &lt;code&gt;filter wizard&lt;/code&gt; 即可自定义过滤追踪。
skywalking通过加载apm-trace-ignore-plugin插件就能自定义过滤跟踪，skywalking这种方式更灵活，比如一台高配服务器上有若干个服务，在共用的agent配置文件apm-trace-ignore-plugin.config中可以配置通用的过滤规则，然后通过-D的方式为每个服务配置个性化过滤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，在过滤追踪方面，skywalking更胜一筹&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;性能损耗&#34;&gt;&lt;strong&gt;性能损耗&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于Pinpoint采集信息太过详细，所以，它对性能的损耗最大。而skywalking默认策略比较保守，对性能损耗很小。
有网友做过压力测试，对比如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4kk0bgjj30yg0ae45o.jpg&#34; alt=&#34;压力测试&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图片来源于：https://juejin.im/post/5a7a9e0af265da4e914b46f1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所以，在性能损耗方面，skywalking更胜一筹&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;发布包比较&#34;&gt;&lt;strong&gt;发布包比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;skywalking与时俱进，全系标配jar包，部署只需要执行start.sh脚本即可。而Pinpoint的collector和web还是war包，部署时依赖web容器（比如Tomcat）。拜托，都9012年了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，在发布包方面，skywalking更胜一筹&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;支持组件比较&#34;&gt;&lt;strong&gt;支持组件比较&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;0081Kckwly1gkl4kkfvddj30ox0sx74l.jpg&#34; alt=&#34;支持组件对比&#34;&gt;&lt;/p&gt;
&lt;p&gt;skywalking和Pinpoint支持的中间件对比说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;WEB容器说明&lt;/strong&gt;：Pinpoint支持几乎所有的WEB容器，包括开源和商业的。而wkywalking只支持开源的WEB容器，对2款大名鼎鼎的商业WEB容器Weblogic和Wevsphere都不支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RPC框架说明&lt;/strong&gt;：对RPC框架的支持，skywalking简直秒杀Pinpoint。连小众的motan和sofarpc都支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MQ说明&lt;/strong&gt;：skywalking比Pinpoint多支持一个国产的MQ中间件RocketMQ，毕竟RocketMQ在国内名气大，而在国外就一般了。加之skywalking也是国产的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RDBMS/NoSQL说明&lt;/strong&gt;：Pinpoint对RDBMS和NoSQL的支持都要略好于skywalking，RDBMS方面，skywalking不支持MSSQL和MariaDB。而NoSQL方面，skywalking不支持Cassandra和HBase。至于Pinpoint不支持的H2，完全不是问题，毕竟生产环境是肯定不会使用H2作为底层存储的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis客户端说明&lt;/strong&gt;：虽然skywalking和Pinpoint都支持Redis，但是skywalking支持三种流行的Redis客户端：Jedis，Redisson，Lettuce。而Pinpoint只支持Jedis和Lettuce，再一次，韩国人开发的Pinpoint无视了目前中国人开发的GitHub上star最多的Redis Client &amp;ndash; Redisson。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志框架说明&lt;/strong&gt;：Pinpoint居然不支持log4j2？但是已经有人开发了相关功能，详情请戳链接：&lt;a href=&#34;https://github.com/naver/pinpoint/issues/3055&#34;&gt;log4j plugin support log4j2 or not? https://github.com/naver/pinpoint/issues/3055&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过对skywalking和Pinpoint支持中间件的对比我们发现，skywalking对国产软件的支持真的是全方位秒杀Pinpoint，比如小众化的RPC框架：motan（微博出品），sofarpc，阿里的RocketMQ，Redis客户端Redisson，以及分布式任务调度框架elastic-job等。当然也从另一方面反应国产开源软件在世界上的影响力还很小。&lt;/p&gt;
&lt;p&gt;这方面没有谁好谁坏，毕竟每个公司使用的技术栈不一样。如果你对RocketMQ有强需求，那么skywalking是你的最佳选择。如果你对es有强需求，那么skywalking也是你的最佳选择。如果HBase是你的强需求，那么Pinpoint就是你的最佳选择。如果MSSQL是你的强需求，那么Pinpoint也是你的最佳选择。总之，这里完全取决你的项目了。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;经过前面对skywalking和Pinpoint全方位对比后我们发现，对于两款非常优秀的APM软件，有一种既生瑜何生亮的感觉。Pinpoint的优势在于：追踪数据粒度非常细、功能强大的用户界面，以及使用HBase作为存储带来的海量存储能力。而skywalking的优势在于：非常活跃的中文社区，支持多种语言的探针，对国产开源软件非常全面的支持，以及使用es作为底层存储带来的强大的检索能力，并且skywalking的扩展性以及定制化要更优于Pinpoint：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你有海量的日志存储需求，推荐Pinpoint。&lt;/li&gt;
&lt;li&gt;如果你更看重二次开发的便捷性，推荐skywalking。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，参考上面的对比，结合你的需求，哪些不能妥协，哪些可以舍弃，从而更好的选择一款最适合你的APM软件。&lt;/p&gt;
&lt;h3 id=&#34;参考链接&#34;&gt;&lt;strong&gt;参考链接&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;参考[1]. &lt;a href=&#34;https://github.com/apache/incubator-skywalking/blob/master/docs/en/setup/service-agent/java-agent/Supported-list.md&#34;&gt;https://github.com/apache/incubator-skywalking/blob/master/docs/en/setup/service-agent/java-agent/Supported-list.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参考[2]. &lt;a href=&#34;http://naver.github.io/pinpoint/1.8.2/main.html#supported-modules&#34;&gt;http://naver.github.io/pinpoint/1.8.2/main.html#supported-modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参考[3]. &lt;a href=&#34;https://juejin.im/post/5a7a9e0af265da4e914b46f1&#34;&gt;https://juejin.im/post/5a7a9e0af265da4e914b46f1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;如果觉得本文不错，请关注作者公众号：【&lt;strong&gt;阿飞的博客&lt;/strong&gt;】，多谢！&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
  </channel>
</rss>
